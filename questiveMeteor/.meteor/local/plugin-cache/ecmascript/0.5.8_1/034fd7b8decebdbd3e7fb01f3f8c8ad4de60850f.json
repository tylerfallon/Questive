{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"lodash","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_"}]},{"source":"meteor/ddp","imported":["DDP"],"specifiers":[{"kind":"named","imported":"DDP","local":"DDP"}]},{"source":"../utils/document_insert.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"documentInsert"}]},{"source":"../utils/document_update.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"documentUpdate"}]},{"source":"../utils/is_remote.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"isRemote"}]},{"source":"../utils/call_meteor_method.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"callMeteorMethod"}]},{"source":"../../fields/utils/raw_all.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"rawAll"}]},{"source":"../../fields/utils/cast_nested.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"castNested"}]},{"source":"../../storage/utils/get_modifier.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"getModifier"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/jagi:astronomy/lib/modules/storage/class_prototype_methods/save.js","filenameRelative":"/packages/jagi:astronomy/lib/modules/storage/class_prototype_methods/save.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/jagi:astronomy/lib/modules/storage/class_prototype_methods/save.js.map","sourceFileName":"/packages/jagi:astronomy/lib/modules/storage/class_prototype_methods/save.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"save"},"ignored":false,"code":"var _;module.import('lodash',{\"default\":function(v){_=v}});var DDP;module.import('meteor/ddp',{\"DDP\":function(v){DDP=v}});var documentInsert;module.import('../utils/document_insert.js',{\"default\":function(v){documentInsert=v}});var documentUpdate;module.import('../utils/document_update.js',{\"default\":function(v){documentUpdate=v}});var isRemote;module.import('../utils/is_remote.js',{\"default\":function(v){isRemote=v}});var callMeteorMethod;module.import('../utils/call_meteor_method.js',{\"default\":function(v){callMeteorMethod=v}});var rawAll;module.import('../../fields/utils/raw_all.js',{\"default\":function(v){rawAll=v}});var castNested;module.import('../../fields/utils/cast_nested.js',{\"default\":function(v){castNested=v}});var getModifier;module.import('../../storage/utils/get_modifier.js',{\"default\":function(v){getModifier=v}});\n\n\n\n\n\n\n\n\n\nfunction save() {\n  var args = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n  var callback = arguments[1];\n\n  var doc = this;\n  var Class = doc.constructor;\n  var Collection = Class.getCollection();\n\n  // If the first argument is callback function then reassign values.\n  if (arguments.length === 1 && Match.test(args, Function)) {\n    callback = args;\n    args = {};\n  }\n  // Get variables from the first argument.\n  var _args = args;\n  var stopOnFirstError = _args.stopOnFirstError;\n  var simulation = _args.simulation;\n  var fields = _args.fields;\n\n  // Cast nested documents.\n\n  castNested({\n    doc: doc\n  });\n\n  // Detect which operation we are executing.\n  var inserting = doc._isNew;\n\n  // Generate ID if not provided.\n  if (inserting && !doc._id) {\n    var generateId = true;\n    // Don't generate the id if we're the client and the 'outermost' call.\n    // This optimization saves us passing both the randomSeed and the id.\n    // Passing both is redundant.\n    if (Collection._isRemoteCollection()) {\n      var enclosing = DDP._CurrentInvocation.get();\n      if (!enclosing) {\n        generateId = false;\n      }\n    }\n    if (generateId) {\n      doc._id = Collection._makeNewID();\n    }\n  }\n\n  // If we are dealing with a remote collection and we are not on the server.\n  if (isRemote(Class)) {\n    // Prepare meteor method name to be called.\n    var methodName = '/Astronomy/' + (inserting ? 'insert' : 'update');\n    // Prepare arguments for meteor method.\n    var methodArgs = {\n      className: Class.getName(),\n      stopOnFirstError: stopOnFirstError,\n      simulation: simulation\n    };\n    // Inserting.\n    if (inserting) {\n      _.extend(methodArgs, {\n        rawDoc: rawAll(doc, {\n          transient: false\n        })\n      });\n    }\n    // Updating.\n    else {\n        _.extend(methodArgs, {\n          selector: {\n            _id: doc._id\n          },\n          modifier: getModifier({\n            doc: doc\n          }),\n          options: {},\n          fields: fields\n        });\n      }\n\n    try {\n      // Run Meteor method.\n      var result = callMeteorMethod(Class, methodName, [methodArgs], callback);\n      if (result && inserting) {\n        // In the insert operation the value return from the meteor method is\n        // a document ID.\n        doc._id = result;\n      }\n      // A document is not new anymore.\n      doc._isNew = false;\n      return result;\n    }\n    // Catch stub exceptions.\n    catch (err) {\n      if (callback) {\n        callback(err);\n        return null;\n      }\n      throw err;\n    }\n  }\n\n  // If we can just insert a document without calling the meteor method. We may\n  // be on the server or the collection may be local.\n  try {\n    // Prepare arguments.\n    var _methodArgs = {\n      doc: doc,\n      stopOnFirstError: stopOnFirstError,\n      simulation: simulation,\n      trusted: true\n    };\n    if (inserting) {\n      var _result = documentInsert(_methodArgs);\n      if (callback) {\n        callback(undefined, _result);\n      }\n      return _result;\n    } else {\n      _methodArgs.fields = fields;\n      var _result2 = documentUpdate(_methodArgs);\n      if (callback) {\n        callback(undefined, _result2);\n      }\n      return _result2;\n    }\n  } catch (err) {\n    if (callback) {\n      callback(err);\n      return null;\n    }\n    throw err;\n  }\n}\n\nmodule.export(\"default\",exports.default=(save));","ast":null,"map":{"version":3,"sources":["/packages/jagi:astronomy/lib/modules/storage/class_prototype_methods/save.js"],"names":[],"mappings":"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","file":"/packages/jagi:astronomy/lib/modules/storage/class_prototype_methods/save.js.map","sourcesContent":["import _ from 'lodash';\nimport { DDP } from 'meteor/ddp';\nimport documentInsert from '../utils/document_insert.js';\nimport documentUpdate from '../utils/document_update.js';\nimport isRemote from '../utils/is_remote.js';\nimport callMeteorMethod from '../utils/call_meteor_method.js';\nimport rawAll from '../../fields/utils/raw_all.js';\nimport castNested from '../../fields/utils/cast_nested.js';\nimport getModifier from '../../storage/utils/get_modifier.js';\n\nfunction save(args = {}, callback) {\n  const doc = this;\n  const Class = doc.constructor;\n  const Collection = Class.getCollection();\n\n  // If the first argument is callback function then reassign values.\n  if (arguments.length === 1 && Match.test(args, Function)) {\n    callback = args;\n    args = {};\n  }\n  // Get variables from the first argument.\n  const {\n    stopOnFirstError,\n    simulation,\n    fields\n  } = args;\n\n  // Cast nested documents.\n  castNested({\n    doc\n  });\n\n  // Detect which operation we are executing.\n  const inserting = doc._isNew;\n\n  // Generate ID if not provided.\n  if (inserting && !doc._id) {\n    let generateId = true;\n    // Don't generate the id if we're the client and the 'outermost' call.\n    // This optimization saves us passing both the randomSeed and the id.\n    // Passing both is redundant.\n    if (Collection._isRemoteCollection()) {\n      const enclosing = DDP._CurrentInvocation.get();\n      if (!enclosing) {\n        generateId = false;\n      }\n    }\n    if (generateId) {\n      doc._id = Collection._makeNewID();\n    }\n  }\n\n  // If we are dealing with a remote collection and we are not on the server.\n  if (isRemote(Class)) {\n    // Prepare meteor method name to be called.\n    const methodName = '/Astronomy/' + (inserting ? 'insert' : 'update');\n    // Prepare arguments for meteor method.\n    const methodArgs = {\n      className: Class.getName(),\n      stopOnFirstError,\n      simulation,\n    };\n    // Inserting.\n    if (inserting) {\n      _.extend(methodArgs, {\n        rawDoc: rawAll(doc, {\n          transient: false\n        })\n      });\n    }\n    // Updating.\n    else {\n      _.extend(methodArgs, {\n        selector: {\n          _id: doc._id\n        },\n        modifier: getModifier({\n          doc\n        }),\n        options: {},\n        fields\n      });\n    }\n\n    try {\n      // Run Meteor method.\n      const result = callMeteorMethod(\n        Class, methodName, [methodArgs], callback\n      );\n      if (result && inserting) {\n        // In the insert operation the value return from the meteor method is\n        // a document ID.\n        doc._id = result;\n      }\n      // A document is not new anymore.\n      doc._isNew = false;\n      return result;\n    }\n    // Catch stub exceptions.\n    catch (err) {\n      if (callback) {\n        callback(err);\n        return null;\n      }\n      throw err;\n    }\n  }\n\n  // If we can just insert a document without calling the meteor method. We may\n  // be on the server or the collection may be local.\n  try {\n    // Prepare arguments.\n    let methodArgs = {\n      doc,\n      stopOnFirstError,\n      simulation,\n      trusted: true\n    };\n    if (inserting) {\n      let result = documentInsert(methodArgs);\n      if (callback) {\n        callback(undefined, result);\n      }\n      return result;\n    }\n    else {\n      methodArgs.fields = fields;\n      let result = documentUpdate(methodArgs);\n      if (callback) {\n        callback(undefined, result);\n      }\n      return result;\n    }\n  }\n  catch (err) {\n    if (callback) {\n      callback(err);\n      return null;\n    }\n    throw err;\n  }\n}\n\nexport default save;"]},"hash":"034fd7b8decebdbd3e7fb01f3f8c8ad4de60850f"}
