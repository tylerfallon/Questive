{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"lodash","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_"}]},{"source":"../../core/utils/throw_parse_error.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"throwParseError"}]},{"source":"../../../core/class.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Class"}]},{"source":"../type.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Type"}]},{"source":"../../../core/reserved_keywords.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"reservedKeywords"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/jagi:astronomy/lib/modules/fields/hooks/parse_definition.js","filenameRelative":"/packages/jagi:astronomy/lib/modules/fields/hooks/parse_definition.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/jagi:astronomy/lib/modules/fields/hooks/parse_definition.js.map","sourceFileName":"/packages/jagi:astronomy/lib/modules/fields/hooks/parse_definition.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"parse_definition"},"ignored":false,"code":"var _;module.import('lodash',{\"default\":function(v){_=v}});var throwParseError;module.import('../../core/utils/throw_parse_error.js',{\"default\":function(v){throwParseError=v}});var Class;module.import('../../../core/class.js',{\"default\":function(v){Class=v}});var Type;module.import('../type.js',{\"default\":function(v){Type=v}});var reservedKeywords;module.import('../../../core/reserved_keywords.js',{\"default\":function(v){reservedKeywords=v}});\n\n\n\n\n\nvar typePattern = Match.OneOf(Function, [Function]);\n\nfunction onParseDefinition(parsedDefinition, definition, className) {\n\tif (definition.fields === undefined) {\n\t\treturn;\n\t}\n\n\t// Fields definition has to be an object.\n\tif (!Match.test(definition.fields, Object)) {\n\t\tthrowParseError([{\n\t\t\t'class': className\n\t\t}, {\n\t\t\t'property': 'fields'\n\t\t}, 'Fields definition has to be an object']);\n\t}\n\n\t_.each(definition.fields, function (fieldDefinition, fieldName) {\n\t\tif (Match.test(fieldDefinition, typePattern)) {\n\t\t\tfieldDefinition = {\n\t\t\t\tname: fieldName,\n\t\t\t\ttype: fieldDefinition\n\t\t\t};\n\t\t} else if (Match.test(fieldDefinition, Object)) {\n\t\t\tfieldDefinition = _.extend(fieldDefinition, {\n\t\t\t\tname: fieldName\n\t\t\t});\n\t\t} else {\n\t\t\tthrowParseError([{\n\t\t\t\t'class': className\n\t\t\t}, {\n\t\t\t\t'property': 'fields'\n\t\t\t}, {\n\t\t\t\t'field': fieldName\n\t\t\t}, 'Field definition has to be an object or type']);\n\t\t}\n\n\t\t// Check if a field name is not reserved keyword.\n\t\tif (_.includes(reservedKeywords, fieldName)) {\n\t\t\tthrowParseError([{\n\t\t\t\t'class': className\n\t\t\t}, {\n\t\t\t\t'method': fieldName\n\t\t\t}, 'Reserved keyword']);\n\t\t}\n\n\t\tparsedDefinition.fields[fieldDefinition.name] = fieldDefinition;\n\t});\n};\n\nmodule.export(\"default\",exports.default=(onParseDefinition));","ast":null,"map":{"version":3,"sources":["/packages/jagi:astronomy/lib/modules/fields/hooks/parse_definition.js"],"names":[],"mappings":"AAAA,OAAO,CAAP,MAAc,QAAd;AACA,OAAO,eAAP,MAA4B,uCAA5B;AACA,OAAO,KAAP,MAAkB,wBAAlB;AACA,OAAO,IAAP,MAAiB,YAAjB;AACA,OAAO,gBAAP,MAA6B,oCAA7B;;AAEA,IAAM,cAAc,MAAM,KAAN,CAAY,QAAZ,EAAsB,CAAC,QAAD,CAAtB,CAApB;;AAEA,SAAS,iBAAT,CAA2B,gBAA3B,EAA6C,UAA7C,EAAyD,SAAzD,EAAoE;AAClE,KAAI,WAAW,MAAX,KAAsB,SAA1B,EAAqC;AACnC;AACD;;;AAGD,KAAI,CAAC,MAAM,IAAN,CAAW,WAAW,MAAtB,EAA8B,MAA9B,CAAL,EAA4C;AAC1C,kBAAgB,CAAC;AACb,YAAS;AADI,GAAD,EAEX;AACD,eAAY;AADX,GAFW,EAKd,uCALc,CAAhB;AAOD;;AAEF,GAAE,IAAF,CAAO,WAAW,MAAlB,EAA0B,UAAS,eAAT,EAA0B,SAA1B,EAAqC;AAC9D,MAAI,MAAM,IAAN,CAAW,eAAX,EAA4B,WAA5B,CAAJ,EAA8C;AAC7C,qBAAkB;AACjB,UAAM,SADW;AAEjB,UAAM;AAFW,IAAlB;AAIA,GALD,MAMK,IAAI,MAAM,IAAN,CAAW,eAAX,EAA4B,MAA5B,CAAJ,EAAyC;AAC7C,qBAAkB,EAAE,MAAF,CAAS,eAAT,EAA0B;AAC3C,UAAM;AADqC,IAA1B,CAAlB;AAGA,GAJI,MAKA;AACJ,mBAAgB,CAAC;AACf,aAAS;AADM,IAAD,EAEZ;AACF,gBAAY;AADV,IAFY,EAIZ;AACF,aAAS;AADP,IAJY,EAOf,8CAPe,CAAhB;AASA;;;AAGC,MAAI,EAAE,QAAF,CAAW,gBAAX,EAA6B,SAA7B,CAAJ,EAA6C;AAC3C,mBAAgB,CAAC;AACb,aAAS;AADI,IAAD,EAEX;AACD,cAAU;AADT,IAFW,EAKd,kBALc,CAAhB;AAOD;;AAEH,mBAAiB,MAAjB,CAAwB,gBAAgB,IAAxC,IAAgD,eAAhD;AACA,EApCD;AAqCA;;AAED,eAAe,iBAAf","file":"/packages/jagi:astronomy/lib/modules/fields/hooks/parse_definition.js.map","sourcesContent":["import _ from 'lodash';\nimport throwParseError from '../../core/utils/throw_parse_error.js';\nimport Class from '../../../core/class.js';\nimport Type from '../type.js';\nimport reservedKeywords from '../../../core/reserved_keywords.js';\n\nconst typePattern = Match.OneOf(Function, [Function]);\n\nfunction onParseDefinition(parsedDefinition, definition, className) {\n  if (definition.fields === undefined) {\n    return;\n  }\n\n  // Fields definition has to be an object.\n  if (!Match.test(definition.fields, Object)) {\n    throwParseError([{\n        'class': className\n      }, {\n        'property': 'fields'\n      },\n      'Fields definition has to be an object'\n    ]);\n  }\n\n\t_.each(definition.fields, function(fieldDefinition, fieldName) {\n\t\tif (Match.test(fieldDefinition, typePattern)) {\n\t\t\tfieldDefinition = {\n\t\t\t\tname: fieldName,\n\t\t\t\ttype: fieldDefinition\n\t\t\t};\n\t\t}\n\t\telse if (Match.test(fieldDefinition, Object)) {\n\t\t\tfieldDefinition = _.extend(fieldDefinition, {\n\t\t\t\tname: fieldName\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tthrowParseError([{\n\t\t\t\t\t'class': className\n\t\t\t\t}, {\n\t\t\t\t\t'property': 'fields'\n\t\t\t\t}, {\n\t\t\t\t\t'field': fieldName\n\t\t\t\t},\n\t\t\t\t'Field definition has to be an object or type'\n\t\t\t]);\n\t\t}\n\n    // Check if a field name is not reserved keyword.\n    if (_.includes(reservedKeywords, fieldName)) {\n      throwParseError([{\n          'class': className\n        }, {\n          'method': fieldName\n        },\n        'Reserved keyword'\n      ]);\n    }\n\n\t\tparsedDefinition.fields[fieldDefinition.name] = fieldDefinition;\n\t});\n};\n\nexport default onParseDefinition;"]},"hash":"22526d1b959bebd9278e03f031ec8f988c7b77e2"}
