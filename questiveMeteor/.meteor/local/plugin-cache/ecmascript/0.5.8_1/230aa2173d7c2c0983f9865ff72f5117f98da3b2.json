{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"lodash","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_"}]},{"source":"../../../core/class.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"AstroClass"}]},{"source":"./already_in_simulation.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"alreadyInSimulation"}]},{"source":"./throw_if_selector_is_not_id.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"throwIfSelectorIsNotId"}]},{"source":"./document_update.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"documentUpdate"}]},{"source":"./apply_modifier.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"applyModifier"}]},{"source":"meteor/minimongo","imported":["Minimongo"],"specifiers":[{"kind":"named","imported":"Minimongo","local":"Minimongo"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/jagi:astronomy/lib/modules/storage/utils/class_update.js","filenameRelative":"/packages/jagi:astronomy/lib/modules/storage/utils/class_update.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/jagi:astronomy/lib/modules/storage/utils/class_update.js.map","sourceFileName":"/packages/jagi:astronomy/lib/modules/storage/utils/class_update.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"class_update"},"ignored":false,"code":"var _;module.import('lodash',{\"default\":function(v){_=v}});var AstroClass;module.import('../../../core/class.js',{\"default\":function(v){AstroClass=v}});var alreadyInSimulation;module.import('./already_in_simulation.js',{\"default\":function(v){alreadyInSimulation=v}});var throwIfSelectorIsNotId;module.import('./throw_if_selector_is_not_id.js',{\"default\":function(v){throwIfSelectorIsNotId=v}});var documentUpdate;module.import('./document_update.js',{\"default\":function(v){documentUpdate=v}});var applyModifier;module.import('./apply_modifier.js',{\"default\":function(v){applyModifier=v}});var Minimongo;module.import('meteor/minimongo',{\"Minimongo\":function(v){Minimongo=v}});\n\n\n\n\n\n\n\nfunction classUpdate() {\n  var args = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n  var className = args.className;\n  var selector = args.selector;\n  var modifier = args.modifier;\n  var options = args.options;\n  var stopOnFirstError = args.stopOnFirstError;\n  var fields = args.fields;\n  var _args$simulation = args.simulation;\n  var simulation = _args$simulation === undefined ? true : _args$simulation;\n  var _args$trusted = args.trusted;\n  var trusted = _args$trusted === undefined ? false : _args$trusted;\n\n  // Stop execution, if we are not on the server, when the \"simulation\" flag is\n  // not set.\n\n  if (!simulation && !Meteor.isServer) {\n    return;\n  }\n\n  // Throw exception if we are trying to perform an operation on more than one\n  // document at once and it's not trusted call.\n  if (!trusted && !alreadyInSimulation()) {\n    throwIfSelectorIsNotId(selector, 'update');\n  }\n\n  var Class = AstroClass.get(className);\n  // Get all documents matching selector.\n  var docs = void 0;\n  if (options.multi) {\n    docs = Class.find(selector, options);\n  } else {\n    docs = Class.find(selector, _.extend(options, {\n      limit: 1\n    }));\n  }\n\n  // Create a minimongo matcher object to find array indexes on the projection\n  // operator use.\n  var matcher = new Minimongo.Matcher(selector);\n\n  // Prepare result of the method execution.\n  var result = 0;\n\n  docs.forEach(function (doc) {\n    // Use matcher to find array indexes in a given document that needs updating\n    // on the projection operator use.\n    var queryResult = matcher.documentMatches(doc);\n\n    // Apply modifier.\n    applyModifier({\n      doc: doc,\n      modifier: modifier,\n      options: queryResult.arrayIndices ? {\n        arrayIndices: queryResult.arrayIndices\n      } : {}\n    });\n\n    // Update a document.\n    result += documentUpdate({\n      doc: doc,\n      stopOnFirstError: stopOnFirstError,\n      simulation: simulation,\n      fields: fields,\n      trusted: trusted\n    });\n  });\n\n  return result;\n};\n\nmodule.export(\"default\",exports.default=(classUpdate));","ast":null,"map":{"version":3,"sources":["/packages/jagi:astronomy/lib/modules/storage/utils/class_update.js"],"names":[],"mappings":"AAAA,OAAO,CAAP,MAAc,QAAd;AACA,OAAO,UAAP,MAAuB,wBAAvB;AACA,OAAO,mBAAP,MAAgC,4BAAhC;AACA,OAAO,sBAAP,MAAmC,kCAAnC;AACA,OAAO,cAAP,MAA2B,sBAA3B;AACA,OAAO,aAAP,MAA0B,qBAA1B;AACA,SAAS,SAAT,QAA0B,kBAA1B;;AAEA,SAAS,WAAT,GAAgC;AAAA,MAAX,IAAW,yDAAJ,EAAI;AAAA,MAE5B,SAF4B,GAU1B,IAV0B,CAE5B,SAF4B;AAAA,MAG5B,QAH4B,GAU1B,IAV0B,CAG5B,QAH4B;AAAA,MAI5B,QAJ4B,GAU1B,IAV0B,CAI5B,QAJ4B;AAAA,MAK5B,OAL4B,GAU1B,IAV0B,CAK5B,OAL4B;AAAA,MAM5B,gBAN4B,GAU1B,IAV0B,CAM5B,gBAN4B;AAAA,MAO5B,MAP4B,GAU1B,IAV0B,CAO5B,MAP4B;AAAA,yBAU1B,IAV0B,CAQ5B,UAR4B;AAAA,MAQ5B,UAR4B,oCAQf,IARe;AAAA,sBAU1B,IAV0B,CAS5B,OAT4B;AAAA,MAS5B,OAT4B,iCASlB,KATkB;;;;;AAc9B,MAAI,CAAC,UAAD,IAAe,CAAC,OAAO,QAA3B,EAAqC;AACnC;AACD;;;;AAID,MAAI,CAAC,OAAD,IAAY,CAAC,qBAAjB,EAAwC;AACtC,2BAAuB,QAAvB,EAAiC,QAAjC;AACD;;AAED,MAAM,QAAQ,WAAW,GAAX,CAAe,SAAf,CAAd;;AAEA,MAAI,aAAJ;AACA,MAAI,QAAQ,KAAZ,EAAmB;AACjB,WAAO,MAAM,IAAN,CAAW,QAAX,EAAqB,OAArB,CAAP;AACD,GAFD,MAGK;AACH,WAAO,MAAM,IAAN,CAAW,QAAX,EAAqB,EAAE,MAAF,CAAS,OAAT,EAAkB;AAC5C,aAAO;AADqC,KAAlB,CAArB,CAAP;AAGD;;;;AAID,MAAM,UAAU,IAAI,UAAU,OAAd,CAAsB,QAAtB,CAAhB;;;AAGA,MAAI,SAAS,CAAb;;AAEA,OAAK,OAAL,CAAa,UAAC,GAAD,EAAS;;;AAGpB,QAAI,cAAc,QAAQ,eAAR,CAAwB,GAAxB,CAAlB;;;AAGA,kBAAc;AACZ,cADY;AAEZ,wBAFY;AAGZ,eAAS,YAAY,YAAZ,GAA2B;AAClC,sBAAc,YAAY;AADQ,OAA3B,GAEL;AALQ,KAAd;;;AASA,cAAU,eAAe;AACvB,cADuB;AAEvB,wCAFuB;AAGvB,4BAHuB;AAIvB,oBAJuB;AAKvB;AALuB,KAAf,CAAV;AAOD,GAtBD;;AAwBA,SAAO,MAAP;AACD;;AAED,eAAe,WAAf","file":"/packages/jagi:astronomy/lib/modules/storage/utils/class_update.js.map","sourcesContent":["import _ from 'lodash';\nimport AstroClass from '../../../core/class.js';\nimport alreadyInSimulation from './already_in_simulation.js';\nimport throwIfSelectorIsNotId from './throw_if_selector_is_not_id.js';\nimport documentUpdate from './document_update.js';\nimport applyModifier from './apply_modifier.js';\nimport { Minimongo } from 'meteor/minimongo';\n\nfunction classUpdate(args = {}) {\n  const {\n    className,\n    selector,\n    modifier,\n    options,\n    stopOnFirstError,\n    fields,\n    simulation = true,\n    trusted = false,\n  } = args;\n\n  // Stop execution, if we are not on the server, when the \"simulation\" flag is\n  // not set.\n  if (!simulation && !Meteor.isServer) {\n    return;\n  }\n\n  // Throw exception if we are trying to perform an operation on more than one\n  // document at once and it's not trusted call.\n  if (!trusted && !alreadyInSimulation()) {\n    throwIfSelectorIsNotId(selector, 'update');\n  }\n\n  const Class = AstroClass.get(className);\n  // Get all documents matching selector.\n  let docs;\n  if (options.multi) {\n    docs = Class.find(selector, options);\n  }\n  else {\n    docs = Class.find(selector, _.extend(options, {\n      limit: 1\n    }));\n  }\n\n  // Create a minimongo matcher object to find array indexes on the projection\n  // operator use.\n  const matcher = new Minimongo.Matcher(selector);\n\n  // Prepare result of the method execution.\n  let result = 0;\n\n  docs.forEach((doc) => {\n    // Use matcher to find array indexes in a given document that needs updating\n    // on the projection operator use.\n    let queryResult = matcher.documentMatches(doc);\n\n    // Apply modifier.\n    applyModifier({\n      doc,\n      modifier,\n      options: queryResult.arrayIndices ? {\n        arrayIndices: queryResult.arrayIndices\n      } : {}\n    });\n\n    // Update a document.\n    result += documentUpdate({\n      doc,\n      stopOnFirstError,\n      simulation,\n      fields,\n      trusted\n    });\n  });\n\n  return result;\n};\n\nexport default classUpdate;"]},"hash":"230aa2173d7c2c0983f9865ff72f5117f98da3b2"}
