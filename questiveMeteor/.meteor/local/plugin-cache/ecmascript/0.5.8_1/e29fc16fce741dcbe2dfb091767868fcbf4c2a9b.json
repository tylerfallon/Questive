{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"../utils/document_remove.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"documentRemove"}]},{"source":"../utils/is_remote.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"isRemote"}]},{"source":"../utils/call_meteor_method.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"callMeteorMethod"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/jagi:astronomy/lib/modules/storage/class_prototype_methods/remove.js","filenameRelative":"/packages/jagi:astronomy/lib/modules/storage/class_prototype_methods/remove.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/jagi:astronomy/lib/modules/storage/class_prototype_methods/remove.js.map","sourceFileName":"/packages/jagi:astronomy/lib/modules/storage/class_prototype_methods/remove.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"remove"},"ignored":false,"code":"var documentRemove;module.import('../utils/document_remove.js',{\"default\":function(v){documentRemove=v}});var isRemote;module.import('../utils/is_remote.js',{\"default\":function(v){isRemote=v}});var callMeteorMethod;module.import('../utils/call_meteor_method.js',{\"default\":function(v){callMeteorMethod=v}});\n\n\n\nfunction remove() {\n  var args = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n  var callback = arguments[1];\n\n  var doc = this;\n  var Class = doc.constructor;\n\n  // If the first argument is callback function then reassign values.\n  if (arguments.length === 1 && Match.test(args, Function)) {\n    callback = args;\n    args = {};\n  }\n  // Get variables from the first argument.\n  var _args = args;\n  var _args$simulation = _args.simulation;\n  var simulation = _args$simulation === undefined ? true : _args$simulation;\n\n  // If we are dealing with a remote collection and we are not on the server.\n\n  if (isRemote(Class)) {\n    // Prepare meteor method name to be called.\n    var methodName = '/Astronomy/remove';\n    // Prepare arguments for the meteor method.\n    var methodArgs = {\n      className: Class.getName(),\n      selector: {\n        _id: doc._id\n      },\n      simulation: simulation\n    };\n\n    try {\n      // Run meteor method.\n      var result = callMeteorMethod(Class, methodName, [methodArgs], callback);\n      // Change the \"_isNew\" flag to \"true\". After removing a document can be\n      // saved again as a new one.\n      doc._isNew = true;\n      // Return result of the meteor method call.\n      return result;\n    }\n    // Catch stub exceptions.\n    catch (err) {\n      if (callback) {\n        callback(err);\n        return null;\n      }\n      throw err;\n    }\n  }\n\n  // If we can just remove a document without calling the meteor method. We may\n  // be on the server or the collection may be local.\n  try {\n    // Prepare arguments.\n    var _methodArgs = {\n      doc: doc,\n      simulation: simulation,\n      trusted: true\n    };\n    var _result = documentRemove(_methodArgs);\n    if (callback) {\n      callback(undefined, _result);\n    }\n    return _result;\n  } catch (err) {\n    if (callback) {\n      callback(err);\n      return null;\n    }\n    throw err;\n  }\n}\n\nmodule.export(\"default\",exports.default=(remove));","ast":null,"map":{"version":3,"sources":["/packages/jagi:astronomy/lib/modules/storage/class_prototype_methods/remove.js"],"names":[],"mappings":"AAAA,OAAO,cAAP,MAA2B,6BAA3B;AACA,OAAO,QAAP,MAAqB,uBAArB;AACA,OAAO,gBAAP,MAA6B,gCAA7B;;AAEA,SAAS,MAAT,GAAqC;AAAA,MAArB,IAAqB,yDAAd,EAAc;AAAA,MAAV,QAAU;;AACnC,MAAI,MAAM,IAAV;AACA,MAAI,QAAQ,IAAI,WAAhB;;;AAGA,MAAI,UAAU,MAAV,KAAqB,CAArB,IAA0B,MAAM,IAAN,CAAW,IAAX,EAAiB,QAAjB,CAA9B,EAA0D;AACxD,eAAW,IAAX;AACA,WAAO,EAAP;AACD;;AARkC,cAY/B,IAZ+B;AAAA,+BAWjC,UAXiC;AAAA,MAWjC,UAXiC,oCAWpB,IAXoB;;;;AAenC,MAAI,SAAS,KAAT,CAAJ,EAAqB;;AAEnB,QAAI,aAAa,mBAAjB;;AAEA,QAAI,aAAa;AACf,iBAAW,MAAM,OAAN,EADI;AAEf,gBAAU;AACR,aAAK,IAAI;AADD,OAFK;AAKf;AALe,KAAjB;;AAQA,QAAI;;AAEF,UAAI,SAAS,iBACX,KADW,EACJ,UADI,EACQ,CAAC,UAAD,CADR,EACsB,QADtB,CAAb;;;AAKA,UAAI,MAAJ,GAAa,IAAb;;AAEA,aAAO,MAAP;AACD;;AAED,WAAO,GAAP,EAAY;AACV,UAAI,QAAJ,EAAc;AACZ,iBAAS,GAAT;AACA,eAAO,IAAP;AACD;AACD,YAAM,GAAN;AACD;AACF;;;;AAID,MAAI;;AAEF,QAAI,cAAa;AACf,cADe;AAEf,4BAFe;AAGf,eAAS;AAHM,KAAjB;AAKA,QAAI,UAAS,eAAe,WAAf,CAAb;AACA,QAAI,QAAJ,EAAc;AACZ,eAAS,SAAT,EAAoB,OAApB;AACD;AACD,WAAO,OAAP;AACD,GAZD,CAaA,OAAO,GAAP,EAAY;AACV,QAAI,QAAJ,EAAc;AACZ,eAAS,GAAT;AACA,aAAO,IAAP;AACD;AACD,UAAM,GAAN;AACD;AACF;;AAED,eAAe,MAAf","file":"/packages/jagi:astronomy/lib/modules/storage/class_prototype_methods/remove.js.map","sourcesContent":["import documentRemove from '../utils/document_remove.js';\nimport isRemote from '../utils/is_remote.js';\nimport callMeteorMethod from '../utils/call_meteor_method.js';\n\nfunction remove(args = {}, callback) {\n  let doc = this;\n  let Class = doc.constructor;\n\n  // If the first argument is callback function then reassign values.\n  if (arguments.length === 1 && Match.test(args, Function)) {\n    callback = args;\n    args = {};\n  }\n  // Get variables from the first argument.\n  let {\n    simulation = true\n  } = args;\n\n  // If we are dealing with a remote collection and we are not on the server.\n  if (isRemote(Class)) {\n    // Prepare meteor method name to be called.\n    let methodName = '/Astronomy/remove';\n    // Prepare arguments for the meteor method.\n    let methodArgs = {\n      className: Class.getName(),\n      selector: {\n        _id: doc._id\n      },\n      simulation\n    };\n\n    try {\n      // Run meteor method.\n      let result = callMeteorMethod(\n        Class, methodName, [methodArgs], callback\n      );\n      // Change the \"_isNew\" flag to \"true\". After removing a document can be\n      // saved again as a new one.\n      doc._isNew = true;\n      // Return result of the meteor method call.\n      return result;\n    }\n    // Catch stub exceptions.\n    catch (err) {\n      if (callback) {\n        callback(err);\n        return null;\n      }\n      throw err;\n    }\n  }\n\n  // If we can just remove a document without calling the meteor method. We may\n  // be on the server or the collection may be local.\n  try {\n    // Prepare arguments.\n    let methodArgs = {\n      doc,\n      simulation,\n      trusted: true\n    };\n    let result = documentRemove(methodArgs);\n    if (callback) {\n      callback(undefined, result);\n    }\n    return result;\n  }\n  catch (err) {\n    if (callback) {\n      callback(err);\n      return null;\n    }\n    throw err;\n  }\n}\n\nexport default remove;"]},"hash":"e29fc16fce741dcbe2dfb091767868fcbf4c2a9b"}
