{"metadata":{"usedHelpers":["classCallCheck","inherits","possibleConstructorReturn"],"marked":[],"modules":{"imports":[{"source":"lodash","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_"}]},{"source":"../core/utils/throw_parse_error.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"throwParseError"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/jagi:astronomy/lib/modules/behaviors/behavior.js","filenameRelative":"/packages/jagi:astronomy/lib/modules/behaviors/behavior.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/jagi:astronomy/lib/modules/behaviors/behavior.js.map","sourceFileName":"/packages/jagi:astronomy/lib/modules/behaviors/behavior.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"behavior"},"ignored":false,"code":"var _possibleConstructorReturn;module.import('babel-runtime/helpers/possibleConstructorReturn',{\"default\":function(v){_possibleConstructorReturn=v}});var _inherits;module.import('babel-runtime/helpers/inherits',{\"default\":function(v){_inherits=v}});var _classCallCheck;module.import('babel-runtime/helpers/classCallCheck',{\"default\":function(v){_classCallCheck=v}});var _;module.import('lodash',{\"default\":function(v){_=v}});var throwParseError;module.import('../core/utils/throw_parse_error.js',{\"default\":function(v){throwParseError=v}});\n\n\n\n\n\nvar checkDefinition = function checkDefinition(definition) {\n\t// Check parameters validity.\n\tif (!Match.test(definition, Object)) {\n\t\tthrowParseError(['Behavior definition has to be an object']);\n\t}\n\n\t// Check if behavior name is provided and is a string.\n\tif (!Match.test(definition.name, String)) {\n\t\tthrowParseError(['Behavior has to be named']);\n\t}\n\n\t// Check if behavior with a given name already exists.\n\tif (_.has(Behavior.behaviors, definition.name)) {\n\t\tthrowParseError([{\n\t\t\t'behavior': definition.name\n\t\t}, 'Behavior already exists']);\n\t}\n};\n\nvar Behavior = function () {\n\tfunction Behavior(options) {\n\t\t_classCallCheck(this, Behavior);\n\n\t\tthis.options = _.extend({}, this.options, options);\n\t}\n\n\tBehavior.prototype.createClassDefinition = function () {\n\t\tfunction createClassDefinition() {}\n\n\t\treturn createClassDefinition;\n\t}();\n\n\tBehavior.prototype.apply = function () {\n\t\tfunction apply(Class) {\n\t\t\tvar definition = this.createClassDefinition();\n\t\t\tif (definition) {\n\t\t\t\tClass.extend(definition);\n\t\t\t}\n\t\t}\n\n\t\treturn apply;\n\t}();\n\n\tBehavior.create = function () {\n\t\tfunction create(definition) {\n\t\t\tcheckDefinition(definition);\n\n\t\t\t// Get behavior name.\n\t\t\tvar behaviorName = definition.name;\n\t\t\t// Extend the Behavior class.\n\t\t\tvar Behavior = this.behaviors[behaviorName] = function (_ref) {\n\t\t\t\t_inherits(Behavior, _ref);\n\n\t\t\t\tfunction Behavior() {\n\t\t\t\t\t_classCallCheck(this, Behavior);\n\n\t\t\t\t\treturn _possibleConstructorReturn(this, _ref.apply(this, arguments));\n\t\t\t\t}\n\n\t\t\t\treturn Behavior;\n\t\t\t}(this);\n\t\t\t// Store definition in behavior class.\n\t\t\tBehavior.definition = definition;\n\t\t\t// Extend prototype with a definition.\n\t\t\t_.extend(Behavior.prototype, definition);\n\n\t\t\treturn Behavior;\n\t\t}\n\n\t\treturn create;\n\t}();\n\n\tBehavior.get = function () {\n\t\tfunction get(behaviorName) {\n\t\t\treturn this.behaviors[behaviorName];\n\t\t}\n\n\t\treturn get;\n\t}();\n\n\tBehavior.has = function () {\n\t\tfunction has(behaviorName) {\n\t\t\treturn _.has(this.behaviors, behaviorName);\n\t\t}\n\n\t\treturn has;\n\t}();\n\n\treturn Behavior;\n}();\n\n;\n\nBehavior.behaviors = {};\n\nmodule.export(\"default\",exports.default=(Behavior));","ast":null,"map":{"version":3,"sources":["/packages/jagi:astronomy/lib/modules/behaviors/behavior.js"],"names":[],"mappings":";;;AAAA,OAAO,CAAP,MAAc,QAAd;AACA,OAAO,eAAP,MAA4B,oCAA5B;;AAEA,IAAM,kBAAkB,SAAlB,eAAkB,CAAS,UAAT,EAAqB;;AAE5C,KAAI,CAAC,MAAM,IAAN,CAAW,UAAX,EAAuB,MAAvB,CAAL,EAAqC;AACpC,kBAAgB,CACf,yCADe,CAAhB;AAGA;;;AAGD,KAAI,CAAC,MAAM,IAAN,CAAW,WAAW,IAAtB,EAA4B,MAA5B,CAAL,EAA0C;AACzC,kBAAgB,CACf,0BADe,CAAhB;AAGA;;;AAGD,KAAI,EAAE,GAAF,CAAM,SAAS,SAAf,EAA0B,WAAW,IAArC,CAAJ,EAAgD;AAC/C,kBAAgB,CAAC;AACf,eAAY,WAAW;AADR,GAAD,EAGf,yBAHe,CAAhB;AAKA;AACD,CAvBD;;IAyBM,Q;AACL,mBAAY,OAAZ,EAAqB;AAAA;;AACpB,OAAK,OAAL,GAAe,EAAE,MAAF,CAAS,EAAT,EAAa,KAAK,OAAlB,EAA2B,OAA3B,CAAf;AACA;;oBAED,qB;mCAAwB,CAAE;;;;;oBAE1B,K;iBAAM,K,EAAO;AACZ,OAAI,aAAa,KAAK,qBAAL,EAAjB;AACA,OAAI,UAAJ,EAAgB;AACf,UAAM,MAAN,CAAa,UAAb;AACA;AACD;;;;;UAEM,M;kBAAO,U,EAAY;AACzB,mBAAgB,UAAhB;;;AAGA,OAAI,eAAe,WAAW,IAA9B;;AAEA,OAAI,WAAW,KAAK,SAAL,CAAe,YAAf;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA,KAAsD,IAAtD,CAAf;;AAEA,YAAS,UAAT,GAAsB,UAAtB;;AAEA,KAAE,MAAF,CAAS,SAAS,SAAlB,EAA6B,UAA7B;;AAEA,UAAO,QAAP;AACA;;;;;UAEM,G;eAAI,Y,EAAc;AACxB,UAAO,KAAK,SAAL,CAAe,YAAf,CAAP;AACA;;;;;UAEM,G;eAAI,Y,EAAc;AACxB,UAAO,EAAE,GAAF,CAAM,KAAK,SAAX,EAAsB,YAAtB,CAAP;AACA;;;;;;;;AACD;;AAED,SAAS,SAAT,GAAqB,EAArB;;AAEA,eAAe,QAAf","file":"/packages/jagi:astronomy/lib/modules/behaviors/behavior.js.map","sourcesContent":["import _ from 'lodash';\nimport throwParseError from '../core/utils/throw_parse_error.js';\n\nconst checkDefinition = function(definition) {\n\t// Check parameters validity.\n\tif (!Match.test(definition, Object)) {\n\t\tthrowParseError([\n\t\t\t'Behavior definition has to be an object'\n\t\t]);\n\t}\n\n\t// Check if behavior name is provided and is a string.\n\tif (!Match.test(definition.name, String)) {\n\t\tthrowParseError([\n\t\t\t'Behavior has to be named'\n\t\t]);\n\t}\n\n\t// Check if behavior with a given name already exists.\n\tif (_.has(Behavior.behaviors, definition.name)) {\n\t\tthrowParseError([{\n\t\t\t\t'behavior': definition.name\n\t\t\t},\n\t\t\t'Behavior already exists'\n\t\t]);\n\t}\n};\n\nclass Behavior {\n\tconstructor(options) {\n\t\tthis.options = _.extend({}, this.options, options);\n\t}\n\n\tcreateClassDefinition() {}\n\n\tapply(Class) {\n\t\tlet definition = this.createClassDefinition();\n\t\tif (definition) {\n\t\t\tClass.extend(definition);\n\t\t}\n\t}\n\n\tstatic create(definition) {\n\t\tcheckDefinition(definition);\n\n\t\t// Get behavior name.\n\t\tlet behaviorName = definition.name;\n\t\t// Extend the Behavior class.\n\t\tlet Behavior = this.behaviors[behaviorName] = class Behavior extends this {};\n\t\t// Store definition in behavior class.\n\t\tBehavior.definition = definition;\n\t\t// Extend prototype with a definition.\n\t\t_.extend(Behavior.prototype, definition);\n\n\t\treturn Behavior;\n\t}\n\n\tstatic get(behaviorName) {\n\t\treturn this.behaviors[behaviorName];\n\t}\n\n\tstatic has(behaviorName) {\n\t\treturn _.has(this.behaviors, behaviorName);\n\t}\n};\n\nBehavior.behaviors = {};\n\nexport default Behavior;"]},"hash":"c0801756501af530031c57a86ffa85de3d85c337"}
