{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"lodash","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_"}]},{"source":"../../../core/class.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"AstroClass"}]},{"source":"../../core/utils/throw_parse_error.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"throwParseError"}]},{"source":"../../fields/utils/cast_nested.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"castNested"}]},{"source":"../../fields/utils/is_nested_field_name.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"isNestedFieldName"}]},{"source":"../../fields/utils/traverse.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"traverse"}]},{"source":"../../fields/ObjectField","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"ObjectField"}]},{"source":"../../fields/ListField","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"ListField"}]},{"source":"../validators.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Validators"}]},{"source":"meteor/mdg:validation-error","imported":["ValidationError"],"specifiers":[{"kind":"named","imported":"ValidationError","local":"ValidationError"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/jagi:astronomy/lib/modules/validators/utils/document_validate.js","filenameRelative":"/packages/jagi:astronomy/lib/modules/validators/utils/document_validate.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/jagi:astronomy/lib/modules/validators/utils/document_validate.js.map","sourceFileName":"/packages/jagi:astronomy/lib/modules/validators/utils/document_validate.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"document_validate"},"ignored":false,"code":"var _;module.import('lodash',{\"default\":function(v){_=v}});var AstroClass;module.import('../../../core/class.js',{\"default\":function(v){AstroClass=v}});var throwParseError;module.import('../../core/utils/throw_parse_error.js',{\"default\":function(v){throwParseError=v}});var castNested;module.import('../../fields/utils/cast_nested.js',{\"default\":function(v){castNested=v}});var isNestedFieldName;module.import('../../fields/utils/is_nested_field_name.js',{\"default\":function(v){isNestedFieldName=v}});var traverse;module.import('../../fields/utils/traverse.js',{\"default\":function(v){traverse=v}});var ObjectField;module.import('../../fields/ObjectField',{\"default\":function(v){ObjectField=v}});var ListField;module.import('../../fields/ListField',{\"default\":function(v){ListField=v}});var Validators;module.import('../validators.js',{\"default\":function(v){Validators=v}});var ValidationError;module.import('meteor/mdg:validation-error',{\"ValidationError\":function(v){ValidationError=v}});\n\n\n\n\n\n\n\n\n\n\nfunction documentValidate() {\n  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n  var doc = options.doc;\n  var fields = options.fields;\n  var _options$prefix = options.prefix;\n  var prefix = _options$prefix === undefined ? '' : _options$prefix;\n  var _options$stopOnFirstE = options.stopOnFirstError;\n  var stopOnFirstError = _options$stopOnFirstE === undefined ? true : _options$stopOnFirstE;\n  var _options$simulation = options.simulation;\n  var simulation = _options$simulation === undefined ? true : _options$simulation;\n\n  // Stop execution, if we are not on the server, when the \"simulation\" flag is\n  // not set.\n\n  if (!simulation && !Meteor.isServer) {\n    return;\n  }\n\n  var Class = doc.constructor;\n\n  // Cast nested fields.\n  castNested({\n    doc: doc\n  });\n\n  // Prepare array for storing errors list.\n  var errors = [];\n\n  // Helper function for catching and collecting errors.\n  var catchValidationError = function catchValidationError(func) {\n    try {\n      func();\n    } catch (err) {\n      // If it's ValidationError.\n      if (ValidationError.is(err)) {\n        // If we stop on first error then just throw error again.\n        if (stopOnFirstError) {\n          throw err;\n        }\n        // Otherwise we collect errors.\n        else {\n            _.each(err.details, function (details) {\n              errors.push(details);\n            });\n          }\n      }\n      // It it's not ValidationError, then we throw error again.\n      else {\n          throw err;\n        }\n    }\n  };\n\n  // If no fields were passed to validation, then we pick default validation\n  // order.\n  if (!fields) {\n    fields = Class.getValidationOrder();\n  }\n\n  _.each(fields, function (name) {\n    // If it is a nested field pattern name then we have to look for the most\n    // nested document and validate the nested field.\n    if (isNestedFieldName(name)) {\n      traverse(doc, name, function (nestedDoc, nestedName, field) {\n        catchValidationError(function () {\n          documentValidate({\n            doc: nestedDoc,\n            fields: [nestedName],\n            prefix: name.substr(0, name.lastIndexOf(nestedName)),\n            stopOnFirstError: stopOnFirstError,\n            simulation: simulation\n          });\n        });\n      });\n      return;\n    }\n\n    var field = Class.getField(name);\n\n    // Move to the next one if a field does not exist.\n    if (!field) {\n      return;\n    }\n\n    // We do not validate transient fields.\n    if (field.transient) {\n      return;\n    }\n\n    // Get value of the field.\n    var value = doc.get(name);\n\n    // If a field is optional and value is undefined then we do not validate.\n    if (field.getOptional(doc) && _.isNil(value)) {\n      return;\n    }\n\n    // Execute validation in the try-catch block. That's because we want to\n    // continue validation if the \"stopOnFirstError\" flag is set to false.\n    catchValidationError(function () {\n      // First, execute type level validators.\n      field.validate({\n        doc: doc,\n        name: prefix + name,\n        nestedName: name,\n        value: value\n      });\n      // Get validators for a given field.\n      var validators = Class.getValidators(name);\n      _.each(validators, function (_ref) {\n        var type = _ref.type;\n        var param = _ref.param;\n        var resolveParam = _ref.resolveParam;\n        var message = _ref.message;\n        var resolveError = _ref.resolveError;\n\n        // Get validation helper function.\n        var validationFunction = Validators[type];\n        // Execute single validator.\n        validationFunction({\n          doc: doc,\n          name: prefix + name,\n          nestedName: name,\n          value: value,\n          param: param,\n          resolveParam: resolveParam,\n          message: message,\n          resolveError: resolveError\n        });\n      });\n    });\n\n    // If it is the object field then validate it.\n    if (field instanceof ObjectField) {\n      if (value instanceof AstroClass) {\n        catchValidationError(function () {\n          documentValidate({\n            doc: value,\n            fields: value.constructor.getValidationOrder(),\n            prefix: field.name + '.',\n            stopOnFirstError: stopOnFirstError\n          });\n        });\n      }\n    }\n    // If it is the list field then validate each one.\n    else if (field instanceof ListField && field.isClass) {\n        _.each(value, function (element, index) {\n          if (element instanceof AstroClass) {\n            catchValidationError(function () {\n              documentValidate({\n                doc: element,\n                fields: element.constructor.getValidationOrder(),\n                prefix: field.name + '.' + index + '.',\n                stopOnFirstError: stopOnFirstError\n              });\n            });\n          }\n        });\n      }\n  });\n\n  // If we have not thrown any error yet then it means that there are no errors\n  // or we do not throw on the first error.\n  if (errors.length > 0) {\n    throw new ValidationError(errors, errors[0].message);\n  }\n};\n\nmodule.export(\"default\",exports.default=(documentValidate));","ast":null,"map":{"version":3,"sources":["/packages/jagi:astronomy/lib/modules/validators/utils/document_validate.js"],"names":[],"mappings":"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","file":"/packages/jagi:astronomy/lib/modules/validators/utils/document_validate.js.map","sourcesContent":["import _ from 'lodash';\nimport AstroClass from '../../../core/class.js';\nimport throwParseError from '../../core/utils/throw_parse_error.js';\nimport castNested from '../../fields/utils/cast_nested.js';\nimport isNestedFieldName from '../../fields/utils/is_nested_field_name.js';\nimport traverse from '../../fields/utils/traverse.js';\nimport ObjectField from '../../fields/ObjectField';\nimport ListField from '../../fields/ListField';\nimport Validators from '../validators.js';\nimport { ValidationError } from 'meteor/mdg:validation-error';\n\nfunction documentValidate(options = {}) {\n  let {\n    doc,\n    fields,\n    prefix = '',\n    stopOnFirstError = true,\n    simulation = true\n  } = options;\n\n  // Stop execution, if we are not on the server, when the \"simulation\" flag is\n  // not set.\n  if (!simulation && !Meteor.isServer) {\n    return;\n  }\n\n  let Class = doc.constructor;\n\n  // Cast nested fields.\n  castNested({\n    doc\n  });\n\n  // Prepare array for storing errors list.\n  let errors = [];\n\n  // Helper function for catching and collecting errors.\n  const catchValidationError = (func) => {\n    try {\n      func();\n    }\n    catch (err) {\n      // If it's ValidationError.\n      if (ValidationError.is(err)) {\n        // If we stop on first error then just throw error again.\n        if (stopOnFirstError) {\n          throw err;\n        }\n        // Otherwise we collect errors.\n        else {\n          _.each(err.details, (details) => {\n            errors.push(details);\n          });\n        }\n      }\n      // It it's not ValidationError, then we throw error again.\n      else {\n        throw err;\n      }\n    }\n  };\n\n  // If no fields were passed to validation, then we pick default validation\n  // order.\n  if (!fields) {\n    fields = Class.getValidationOrder();\n  }\n\n  _.each(fields, (name) => {\n    // If it is a nested field pattern name then we have to look for the most\n    // nested document and validate the nested field.\n    if (isNestedFieldName(name)) {\n      traverse(doc, name, (nestedDoc, nestedName, field) => {\n        catchValidationError(() => {\n          documentValidate({\n            doc: nestedDoc,\n            fields: [nestedName],\n            prefix: name.substr(0, name.lastIndexOf(nestedName)),\n            stopOnFirstError,\n            simulation\n          });\n        });\n      });\n      return;\n    }\n\n    let field = Class.getField(name);\n\n    // Move to the next one if a field does not exist.\n    if (!field) {\n      return;\n    }\n\n    // We do not validate transient fields.\n    if (field.transient) {\n      return;\n    }\n\n    // Get value of the field.\n    let value = doc.get(name);\n\n    // If a field is optional and value is undefined then we do not validate.\n    if (field.getOptional(doc) && _.isNil(value)) {\n      return;\n    }\n\n    // Execute validation in the try-catch block. That's because we want to\n    // continue validation if the \"stopOnFirstError\" flag is set to false.\n    catchValidationError(() => {\n      // First, execute type level validators.\n      field.validate({\n        doc,\n        name: prefix + name,\n        nestedName: name,\n        value\n      });\n      // Get validators for a given field.\n      let validators = Class.getValidators(name);\n      _.each(validators, ({\n        type,\n        param,\n        resolveParam,\n        message,\n        resolveError\n      }) => {\n        // Get validation helper function.\n        let validationFunction = Validators[type];\n        // Execute single validator.\n        validationFunction({\n          doc,\n          name: prefix + name,\n          nestedName: name,\n          value,\n          param,\n          resolveParam,\n          message,\n          resolveError\n        });\n      });\n    });\n\n    // If it is the object field then validate it.\n    if (field instanceof ObjectField) {\n      if (value instanceof AstroClass) {\n        catchValidationError(() => {\n          documentValidate({\n            doc: value,\n            fields: value.constructor.getValidationOrder(),\n            prefix: field.name + '.',\n            stopOnFirstError\n          });\n        });\n      }\n    }\n    // If it is the list field then validate each one.\n    else if (field instanceof ListField && field.isClass) {\n      _.each(value, (element, index) => {\n        if (element instanceof AstroClass) {\n          catchValidationError(() => {\n            documentValidate({\n              doc: element,\n              fields: element.constructor.getValidationOrder(),\n              prefix: field.name + '.' + index + '.',\n              stopOnFirstError\n            });\n          });\n        }\n      });\n    }\n  });\n\n  // If we have not thrown any error yet then it means that there are no errors\n  // or we do not throw on the first error.\n  if (errors.length > 0) {\n    throw new ValidationError(errors, errors[0].message);\n  }\n};\n\nexport default documentValidate;"]},"hash":"7360b4cded4f2b8aa90310c7188fa66787a664c0"}
