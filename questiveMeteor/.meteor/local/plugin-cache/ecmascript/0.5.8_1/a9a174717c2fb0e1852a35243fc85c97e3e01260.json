{"metadata":{"usedHelpers":["classCallCheck","inherits","possibleConstructorReturn"],"marked":[],"modules":{"imports":[{"source":"lodash","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_"}]},{"source":"meteor/ejson","imported":["EJSON"],"specifiers":[{"kind":"named","imported":"EJSON","local":"EJSON"}]},{"source":"../modules/core/utils/throw_parse_error.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"throwParseError"}]},{"source":"../modules/core/utils/clone_definition.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"cloneDefinition"}]},{"source":"../modules/fields/utils/set_defaults.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"setDefaults"}]},{"source":"../modules/fields/utils/cast_nested.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"castNested"}]},{"source":"./module.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Module"}]},{"source":"../modules/events/event.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Event"}]},{"source":"../modules/fields/type.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Type"}]},{"source":"../modules/validators/validators.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Validators"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/jagi:astronomy/lib/core/class.js","filenameRelative":"/packages/jagi:astronomy/lib/core/class.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/jagi:astronomy/lib/core/class.js.map","sourceFileName":"/packages/jagi:astronomy/lib/core/class.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"class"},"ignored":false,"code":"var _possibleConstructorReturn;module.import('babel-runtime/helpers/possibleConstructorReturn',{\"default\":function(v){_possibleConstructorReturn=v}});var _inherits;module.import('babel-runtime/helpers/inherits',{\"default\":function(v){_inherits=v}});var _classCallCheck;module.import('babel-runtime/helpers/classCallCheck',{\"default\":function(v){_classCallCheck=v}});var _;module.import('lodash',{\"default\":function(v){_=v}});var EJSON;module.import('meteor/ejson',{\"EJSON\":function(v){EJSON=v}});var throwParseError;module.import('../modules/core/utils/throw_parse_error.js',{\"default\":function(v){throwParseError=v}});var cloneDefinition;module.import('../modules/core/utils/clone_definition.js',{\"default\":function(v){cloneDefinition=v}});var setDefaults;module.import('../modules/fields/utils/set_defaults.js',{\"default\":function(v){setDefaults=v}});var castNested;module.import('../modules/fields/utils/cast_nested.js',{\"default\":function(v){castNested=v}});var Module;module.import('./module.js',{\"default\":function(v){Module=v}});var Event;module.import('../modules/events/event.js',{\"default\":function(v){Event=v}});var Type;module.import('../modules/fields/type.js',{\"default\":function(v){Type=v}});var Validators;module.import('../modules/validators/validators.js',{\"default\":function(v){Validators=v}});\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar initClass = function initClass(Class) {\n  // Create and store the schema \"definition\" object in the class constructor.\n  // It's a combination of all parent definitions and a definition that\n  // created this class. It's used to create child classes.\n  Class.definition = {};\n  // Create and store the \"schema\" object in the class constructor. It's an\n  // object that contains all the data related with a given class. The\n  // \"schema\" object contains \"computed\" data of the schema \"definition\".\n  // Thanks to that, Astronomy does not need to compute data on the fly and\n  // everything works faster.\n  Class.schema = {};\n  // Create empty array for storing child classes.\n  Class.children = [];\n  // Init the class schema and schema definition.\n  Module.forEach(function (module) {\n    module.onInitSchema(Class.schema, Class.getName());\n    module.onInitDefinition(Class.definition, Class.getName());\n  });\n  // We have to call the \"onInitClass\" hooks in the separate loop after\n  // initiation of the schema and schema definition, because some\n  // \"onInitClass\" hooks can execute the \"Class.extend\" method which requires\n  // schema and schama definition to be initalized.\n  Module.forEach(function (module) {\n    module.onInitClass(Class, Class.getName());\n  });\n};\n\n// Helper variables for passing information about options to nested documents\n// being initialised during construction.\nvar callsCount = 0;\nvar cloneArgs = null;\n\nvar Class = function () {\n  function Class(rawDoc) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Class);\n\n    // Set default options.\n    _.defaults(options, {\n      defaults: true,\n      clone: true\n    });\n\n    if (callsCount === 0 && cloneArgs === null) {\n      cloneArgs = options.clone;\n    }\n    callsCount++;\n\n    var doc = this;\n    var _Class = doc.constructor;\n\n    if (!_Class.getName()) {\n      throw new Error('Can not create instance of the \"Astro.Class\" class');\n    }\n\n    // Trigger the \"beforeInit\" event handlers.\n    doc.dispatchEvent(new Event('beforeInit'));\n\n    // Clone an argument if the \"clone\" option is set.\n    rawDoc = rawDoc || {};\n    if (cloneArgs) {\n      rawDoc = EJSON.clone(rawDoc);\n    }\n\n    // Set values in a document.\n    var fields = _Class.getFields();\n    _.each(fields, function (field) {\n      doc[field.name] = rawDoc[field.name];\n    });\n\n    // Set default values if the \"defaults\" option is set.\n    if (options.defaults) {\n      setDefaults({\n        doc: doc\n      });\n    }\n    // Cast nested documents.\n    castNested({\n      doc: doc,\n      options: {\n        clone: options.clone\n      }\n    });\n\n    // Trigger the \"afterInit\" event handlers.\n    doc.dispatchEvent(new Event('afterInit'));\n\n    // Decrease number of nested documents being initialised.\n    if (callsCount > 0) {\n      callsCount--;\n    }\n    if (callsCount === 0) {\n      cloneArgs = null;\n    }\n  }\n\n  // Method needed for EJSONification.\n\n\n  Class.prototype.typeName = function typeName() {\n    return 'Astronomy';\n  };\n\n  Class.prototype.toJSONValue = function toJSONValue(args) {\n    var doc = this;\n    var Class = doc.constructor;\n\n    var json = {\n      'class': Class.getName()\n    };\n\n    // Trigger the \"toJSONValue\" event handlers.\n    doc.dispatchEvent(new Event('toJSONValue', {\n      json: json\n    }));\n\n    return json;\n  };\n\n  Class.getName = function getName() {\n    return this.className;\n  };\n\n  Class.getParent = function getParent() {\n    if (this.parentClassName) {\n      return this.get(this.parentClassName);\n    }\n  };\n\n  Class.getChildren = function getChildren() {\n    return this.children;\n  };\n\n  Class.create = function create(definition) {\n    // Get class name.\n    var className = definition.name;\n    // Extend the Astro.Class class.\n    var Class = this.classes[className] = function (_ref) {\n      _inherits(Class, _ref);\n\n      function Class() {\n        _classCallCheck(this, Class);\n\n        return _possibleConstructorReturn(this, _ref.apply(this, arguments));\n      }\n\n      return Class;\n    }(this);\n    // Store the class name in the constructor.\n    Class.className = className;\n    // Initialize class.\n    initClass(Class);\n    // Extend class with a definition.\n    Class.extend(definition);\n    // Register a new type.\n    Type.create({\n      name: className,\n      'class': Class,\n      validate: function validate(args) {\n        // Add current class as a param of validator.\n        args.param = Class;\n        Validators['class'](args);\n      }\n    });\n\n    return Class;\n  };\n\n  Class.inherit = function inherit(definition) {\n    var Parent = this;\n    var className = definition.name;\n\n    // Extend the parent class.\n    var Class = this.classes[className] = function (_Parent) {\n      _inherits(Class, _Parent);\n\n      function Class() {\n        _classCallCheck(this, Class);\n\n        return _possibleConstructorReturn(this, _Parent.apply(this, arguments));\n      }\n\n      return Class;\n    }(Parent);\n\n    // Store the class name in the constructor.\n    Class.className = className;\n    // Store the parent class name in the constructor.\n    Class.parentClassName = Parent.getName();\n    // Initialize class.\n    initClass(Class);\n    // Store child class in the parent class.\n    Parent.children.push(Class);\n    // Extend class with the parent class definition.\n    Class.extend(Parent.definition);\n    // Extend class with the definition.\n    Class.extend(definition);\n    // Register a new type.\n    Type.create({\n      name: className,\n      'class': Class,\n      validate: function validate(args) {\n        // Add current class as a param of validator.\n        args.param = Class;\n        Validators['class'](args);\n      }\n    });\n\n    return Class;\n  };\n\n  Class.extend = function extend(extendDefinition, onlyModules) {\n    var _this3 = this;\n\n    if (onlyModules !== undefined && !Match.test(onlyModules, Match.OneOf(String, [String]))) {\n      throwParseError([{\n        'class': this.getName()\n      }, {\n        'method': 'extend'\n      }, 'The second argument has to be a string or an array of strings']);\n    }\n\n    if (Match.test(onlyModules, String)) {\n      onlyModules = [onlyModules];\n    }\n\n    // Clone definition to not modify the original one.\n    extendDefinition = cloneDefinition(extendDefinition);\n\n    Module.forEach(function (module) {\n      // If the second argument was passed, then we only run module hooks for\n      // modules that were listed in the second argument.\n      if (onlyModules !== undefined && !_.includes(onlyModules, module.name)) {\n        return;\n      }\n      // Initialize parsed definition.\n      var parsedDefinition = {};\n      module.onInitDefinition(parsedDefinition, Class.getName());\n      // Parse the extending definition and put parsed properties in the parsed\n      // definition.\n      module.onParseDefinition(parsedDefinition, extendDefinition, _this3.getName());\n      // Apply parsed definition.\n      module.onApplyDefinition(_this3, parsedDefinition, _this3.getName());\n      // Merge parsed definition with a class definition.\n      module.onMergeDefinitions(_this3.definition, parsedDefinition, _this3.getName());\n    });\n  };\n\n  Class.get = function get(className) {\n    return this.classes[className];\n  };\n\n  Class.has = function has(className) {\n    return _.has(this.classes, className);\n  };\n\n  Class.includes = function includes(Class) {\n    return _.includes(this.classes, Class);\n  };\n\n  Class.isParentOf = function isParentOf(Class) {\n    if (!Class || !Class.prototype) {\n      return false;\n    }\n    return this.prototype.isPrototypeOf(Class.prototype);\n  };\n\n  Class.isChildOf = function isChildOf(Class) {\n    if (!Class || !Class.prototype) {\n      return false;\n    }\n    return Class.prototype.isPrototypeOf(this.prototype);\n  };\n\n  return Class;\n}();\n\n;\n\nClass.classes = {};\n\nmodule.export(\"default\",exports.default=(Class));","ast":null,"map":{"version":3,"sources":["/packages/jagi:astronomy/lib/core/class.js"],"names":[],"mappings":"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","file":"/packages/jagi:astronomy/lib/core/class.js.map","sourcesContent":["import _ from 'lodash';\nimport { EJSON } from 'meteor/ejson';\nimport throwParseError from '../modules/core/utils/throw_parse_error.js';\nimport cloneDefinition from '../modules/core/utils/clone_definition.js';\nimport setDefaults from '../modules/fields/utils/set_defaults.js';\nimport castNested from '../modules/fields/utils/cast_nested.js';\nimport Module from './module.js';\nimport Event from '../modules/events/event.js';\nimport Type from '../modules/fields/type.js';\nimport Validators from '../modules/validators/validators.js';\n\nlet initClass = function(Class) {\n  // Create and store the schema \"definition\" object in the class constructor.\n  // It's a combination of all parent definitions and a definition that\n  // created this class. It's used to create child classes.\n  Class.definition = {};\n  // Create and store the \"schema\" object in the class constructor. It's an\n  // object that contains all the data related with a given class. The\n  // \"schema\" object contains \"computed\" data of the schema \"definition\".\n  // Thanks to that, Astronomy does not need to compute data on the fly and\n  // everything works faster.\n  Class.schema = {};\n  // Create empty array for storing child classes.\n  Class.children = [];\n  // Init the class schema and schema definition.\n  Module.forEach((module) => {\n    module.onInitSchema(Class.schema, Class.getName());\n    module.onInitDefinition(Class.definition, Class.getName());\n  });\n  // We have to call the \"onInitClass\" hooks in the separate loop after\n  // initiation of the schema and schema definition, because some\n  // \"onInitClass\" hooks can execute the \"Class.extend\" method which requires\n  // schema and schama definition to be initalized.\n  Module.forEach((module) => {\n    module.onInitClass(Class, Class.getName());\n  });\n};\n\n// Helper variables for passing information about options to nested documents\n// being initialised during construction.\nlet callsCount = 0;\nlet cloneArgs = null;\n\nclass Class {\n  constructor(rawDoc, options = {}) {\n    // Set default options.\n    _.defaults(options, {\n      defaults: true,\n      clone: true\n    });\n\n    if (callsCount === 0 && cloneArgs === null) {\n      cloneArgs = options.clone;\n    }\n    callsCount++;\n\n    const doc = this;\n    const Class = doc.constructor;\n\n    if (!Class.getName()) {\n      throw new Error(\n        'Can not create instance of the \"Astro.Class\" class'\n      );\n    }\n\n    // Trigger the \"beforeInit\" event handlers.\n    doc.dispatchEvent(new Event('beforeInit'));\n\n    // Clone an argument if the \"clone\" option is set.\n    rawDoc = rawDoc || {};\n    if (cloneArgs) {\n      rawDoc = EJSON.clone(rawDoc);\n    }\n\n    // Set values in a document.\n    const fields = Class.getFields();\n    _.each(fields, (field) => {\n      doc[field.name] = rawDoc[field.name];\n    });\n\n    // Set default values if the \"defaults\" option is set.\n    if (options.defaults) {\n      setDefaults({\n        doc\n      });\n    }\n    // Cast nested documents.\n    castNested({\n      doc,\n      options: {\n        clone: options.clone\n      }\n    });\n\n    // Trigger the \"afterInit\" event handlers.\n    doc.dispatchEvent(new Event('afterInit'));\n\n    // Decrease number of nested documents being initialised.\n    if (callsCount > 0) {\n      callsCount--;\n    }\n    if (callsCount === 0) {\n      cloneArgs = null;\n    }\n  }\n\n  // Method needed for EJSONification.\n  typeName() {\n    return 'Astronomy';\n  }\n\n  toJSONValue(args) {\n    let doc = this;\n    let Class = doc.constructor;\n\n    let json = {\n      class: Class.getName()\n    };\n\n    // Trigger the \"toJSONValue\" event handlers.\n    doc.dispatchEvent(new Event('toJSONValue', {\n      json: json\n    }));\n\n    return json;\n  }\n\n  static getName() {\n    return this.className;\n  }\n\n  static getParent() {\n    if (this.parentClassName) {\n      return this.get(this.parentClassName);\n    }\n  }\n\n  static getChildren() {\n    return this.children;\n  }\n\n  static create(definition) {\n    // Get class name.\n    let className = definition.name;\n    // Extend the Astro.Class class.\n    let Class = this.classes[className] = class Class extends this {};\n    // Store the class name in the constructor.\n    Class.className = className;\n    // Initialize class.\n    initClass(Class);\n    // Extend class with a definition.\n    Class.extend(definition);\n    // Register a new type.\n    Type.create({\n      name: className,\n      class: Class,\n      validate(args) {\n        // Add current class as a param of validator.\n        args.param = Class;\n        Validators.class(args);\n      }\n    });\n\n    return Class;\n  }\n\n  static inherit(definition) {\n    const Parent = this;\n    const className = definition.name;\n\n    // Extend the parent class.\n    const Class = this.classes[className] = class Class extends Parent {};\n\n    // Store the class name in the constructor.\n    Class.className = className;\n    // Store the parent class name in the constructor.\n    Class.parentClassName = Parent.getName();\n    // Initialize class.\n    initClass(Class);\n    // Store child class in the parent class.\n    Parent.children.push(Class);\n    // Extend class with the parent class definition.\n    Class.extend(Parent.definition);\n    // Extend class with the definition.\n    Class.extend(definition);\n    // Register a new type.\n    Type.create({\n      name: className,\n      class: Class,\n      validate(args) {\n        // Add current class as a param of validator.\n        args.param = Class;\n        Validators.class(args);\n      }\n    });\n\n    return Class;\n  }\n\n  static extend(extendDefinition, onlyModules) {\n    if (\n      onlyModules !== undefined &&\n      !Match.test(onlyModules, Match.OneOf(String, [String]))\n    ) {\n      throwParseError([{\n          'class': this.getName()\n        }, {\n          'method': 'extend'\n        },\n        'The second argument has to be a string or an array of strings'\n      ]);\n    }\n\n    if (Match.test(onlyModules, String)) {\n      onlyModules = [onlyModules];\n    }\n\n    // Clone definition to not modify the original one.\n    extendDefinition = cloneDefinition(extendDefinition);\n\n    Module.forEach((module) => {\n      // If the second argument was passed, then we only run module hooks for\n      // modules that were listed in the second argument.\n      if (onlyModules !== undefined && !_.includes(onlyModules, module.name)) {\n        return;\n      }\n      // Initialize parsed definition.\n      let parsedDefinition = {};\n      module.onInitDefinition(parsedDefinition, Class.getName());\n      // Parse the extending definition and put parsed properties in the parsed\n      // definition.\n      module.onParseDefinition(parsedDefinition, extendDefinition, this.getName());\n      // Apply parsed definition.\n      module.onApplyDefinition(this, parsedDefinition, this.getName());\n      // Merge parsed definition with a class definition.\n      module.onMergeDefinitions(this.definition, parsedDefinition, this.getName());\n    });\n  }\n\n  static get(className) {\n    return this.classes[className];\n  }\n\n  static has(className) {\n    return _.has(this.classes, className);\n  }\n\n  static includes(Class) {\n    return _.includes(this.classes, Class);\n  }\n\n  static isParentOf(Class) {\n    if (!Class || !Class.prototype) {\n      return false;\n    }\n    return this.prototype.isPrototypeOf(Class.prototype);\n  }\n\n  static isChildOf(Class) {\n    if (!Class || !Class.prototype) {\n      return false;\n    }\n    return Class.prototype.isPrototypeOf(this.prototype);\n  }\n};\n\nClass.classes = {};\n\nexport default Class;"]},"hash":"a9a174717c2fb0e1852a35243fc85c97e3e01260"}
