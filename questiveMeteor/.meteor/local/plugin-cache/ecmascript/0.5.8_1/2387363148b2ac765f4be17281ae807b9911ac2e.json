{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"lodash","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_"}]},{"source":"../../core/utils/throw_parse_error.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"throwParseError"}]},{"source":"../../fields/utils/raw_many.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"rawMany"}]},{"source":"./omit_undefined.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"omitUndefined"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/jagi:astronomy/lib/modules/storage/utils/get_modifier.js","filenameRelative":"/packages/jagi:astronomy/lib/modules/storage/utils/get_modifier.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/jagi:astronomy/lib/modules/storage/utils/get_modifier.js.map","sourceFileName":"/packages/jagi:astronomy/lib/modules/storage/utils/get_modifier.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"get_modifier"},"ignored":false,"code":"var _;module.import('lodash',{\"default\":function(v){_=v}});var throwParseError;module.import('../../core/utils/throw_parse_error.js',{\"default\":function(v){throwParseError=v}});var rawMany;module.import('../../fields/utils/raw_many.js',{\"default\":function(v){rawMany=v}});var omitUndefined;module.import('./omit_undefined.js',{\"default\":function(v){omitUndefined=v}});\n\n\n\n\nfunction diff(_ref) {\n  var oldDoc = _ref.oldDoc;\n  var newDoc = _ref.newDoc;\n  var _ref$prefix = _ref.prefix;\n  var prefix = _ref$prefix === undefined ? '' : _ref$prefix;\n\n  var $set = {};\n  var $unset = {};\n  var $push = {};\n\n  var fieldsNames = _.union(_.keys(oldDoc), _.keys(newDoc));\n  _.each(fieldsNames, function (fieldName) {\n    var oldValue = oldDoc[fieldName];\n    var newValue = newDoc[fieldName];\n\n    if (!EJSON.equals(oldValue, newValue)) {\n      (function () {\n        var nestedPrefix = (prefix && prefix + '.') + fieldName;\n\n        // Compare two objects.\n        if (_.isPlainObject(oldValue) && _.isPlainObject(newValue)) {\n          var _diff = diff({\n            oldDoc: oldValue,\n            newDoc: newValue,\n            prefix: nestedPrefix\n          });\n\n          var $nestedSet = _diff.$set;\n          var $nestedUnset = _diff.$unset;\n          var $nestedPush = _diff.$push;\n\n          _.extend($set, $nestedSet);\n          _.extend($unset, $nestedUnset);\n          _.extend($push, $nestedPush);\n        }\n        // Compare two arrays.\n        else if (_.isArray(oldValue) && _.isArray(newValue)) {\n            (function () {\n\n              // NOTE: We need check a new array size. If its length increased or\n              // stayed the same then all changes can be registered using the $set\n              // modifier. If an array length decreased, then we should slice it.\n              // However it may not be possible if some element has also changed.\n              // In such situation we have to override entire array.\n              var $arraySet = {};\n              var $arrayUnset = {};\n              var $arrayPush = {};\n              // Compare up to number of elements in the array after the change.\n              _.each(newValue, function (newElement, index) {\n                var arrayPrefix = nestedPrefix + '.' + index;\n                var oldElement = oldValue[index];\n                if (!EJSON.equals(oldElement, newElement)) {\n                  // If both array elements are object, then we perform diff between\n                  // them.\n                  if (_.isPlainObject(oldElement) && _.isPlainObject(newElement)) {\n                    // Get a difference between elements.\n\n                    var _diff2 = diff({\n                      oldDoc: oldElement,\n                      newDoc: newElement,\n                      prefix: arrayPrefix\n                    });\n\n                    var $elementSet = _diff2.$set;\n                    var $elementUnset = _diff2.$unset;\n                    var $elementPush = _diff2.$push;\n\n                    _.extend($arraySet, $elementSet);\n                    _.extend($arrayUnset, $elementUnset);\n                    _.extend($arrayPush, $elementPush);\n                  } else {\n                    $arraySet[arrayPrefix] = newElement;\n                  }\n                }\n              });\n\n              // If an array was empty, then we override entire field with a new\n              // array. That way we solve a problem with treating array indexes as\n              // object keys, which cause inserting Object instead of Array into the\n              // Mongo collection.\n              if (oldValue.length === 0 && newValue.length > 0) {\n                $set[nestedPrefix] = newValue;\n              }\n              // Array length increased or stayed the same.\n              else if (newValue.length >= oldValue.length) {\n                  _.extend($set, $arraySet);\n                  _.extend($unset, $arrayUnset);\n                  _.extend($push, $arrayPush);\n                }\n                // Array length decreased.\n                else {\n                    // At least one array element has changed.\n                    // FIXME: Due to an error in MiniMongo it's not possible to apply\n                    // $push modifier with the $slice operator set to positive number.\n                    // That's why the following \"if\" statement is always true and we\n                    // have to override entire array when it was shrinked.\n                    if (true || _.size($arraySet) > 0 || _.size($arrayPush) > 0) {\n                      // So, we need to override entire array with its new state.\n                      $set[nestedPrefix] = newValue;\n                    }\n                    // Array elements have not changed. The array length just shrinked.\n                    else {\n                        $push[nestedPrefix] = {\n                          // We do not want to add any elements, we just want to slice an\n                          // array.\n                          $each: [],\n                          // Slice array to new array length.\n                          $slice: newValue.length\n                        };\n                      }\n                  }\n            })();\n          } else {\n\n            if (newValue !== undefined) {\n              $set[nestedPrefix] = newValue;\n            } else {\n              $unset[nestedPrefix] = '';\n            }\n          }\n      })();\n    }\n  });\n\n  // Return only non empty modifiers.\n  var modifier = {};\n  if (_.size($set)) {\n    modifier.$set = $set;\n  }\n  if (_.size($unset)) {\n    modifier.$unset = $unset;\n  }\n  if (_.size($push)) {\n    modifier.$push = $push;\n  }\n  return modifier;\n};\n\nfunction getModifier(options) {\n  var newDoc = options.doc;\n  var _options$transient = options.transient;\n  var transient = _options$transient === undefined ? false : _options$transient;\n  var _options$immutable = options.immutable;\n  var immutable = _options$immutable === undefined ? false : _options$immutable;\n  var fields = options.fields;\n\n\n  var Class = newDoc.constructor;\n  var opts = {\n    defaults: false\n  };\n  var oldDoc = newDoc._isNew ? new Class({}, opts) : Class.findOne(newDoc._id, opts);\n  // If there is no document before modifications that may mean that we are not\n  // subscribed to the publication publishing given document or we modified the\n  // _id of a document.\n  if (!oldDoc) {\n    throwParseError([{\n      'module': 'storage'\n    }, {\n      'utility': 'getModified'\n    }, 'Can not get a document before modifications. You are not subscribed ' + ('to the publication publishing a \"' + Class.getName() + '\" document with ') + ('the id \"' + newDoc._id + '\" or you have modified the \"_id\" field')]);\n  }\n\n  // If there are not fields specified, then get all of them.\n  if (!fields) {\n    fields = Class.getFieldsNames();\n  }\n\n  return diff({\n    // Get raw data from the docs.\n    oldDoc: omitUndefined(rawMany(oldDoc, fields, {\n      transient: transient,\n      immutable: immutable\n    })),\n    newDoc: omitUndefined(rawMany(newDoc, fields, {\n      transient: transient,\n      immutable: immutable\n    }))\n  });\n};\n\nmodule.export(\"default\",exports.default=(getModifier));","ast":null,"map":{"version":3,"sources":["/packages/jagi:astronomy/lib/modules/storage/utils/get_modifier.js"],"names":[],"mappings":"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","file":"/packages/jagi:astronomy/lib/modules/storage/utils/get_modifier.js.map","sourcesContent":["import _ from 'lodash';\nimport throwParseError from '../../core/utils/throw_parse_error.js';\nimport rawMany from '../../fields/utils/raw_many.js';\nimport omitUndefined from './omit_undefined.js';\n\nfunction diff({\n  oldDoc,\n  newDoc,\n  prefix = ''\n}) {\n  let $set = {};\n  let $unset = {};\n  let $push = {};\n\n  const fieldsNames = _.union(_.keys(oldDoc), _.keys(newDoc));\n  _.each(fieldsNames, function(fieldName) {\n    const oldValue = oldDoc[fieldName];\n    const newValue = newDoc[fieldName];\n\n    if (!EJSON.equals(oldValue, newValue)) {\n      const nestedPrefix = (prefix && prefix + '.') + fieldName;\n\n      // Compare two objects.\n      if (_.isPlainObject(oldValue) && _.isPlainObject(newValue)) {\n\n        let {\n          $set: $nestedSet,\n          $unset: $nestedUnset,\n          $push: $nestedPush\n        } = diff({\n          oldDoc: oldValue,\n          newDoc: newValue,\n          prefix: nestedPrefix\n        });\n        _.extend($set, $nestedSet);\n        _.extend($unset, $nestedUnset);\n        _.extend($push, $nestedPush);\n\n      }\n      // Compare two arrays.\n      else if (_.isArray(oldValue) && _.isArray(newValue)) {\n\n        // NOTE: We need check a new array size. If its length increased or\n        // stayed the same then all changes can be registered using the $set\n        // modifier. If an array length decreased, then we should slice it.\n        // However it may not be possible if some element has also changed.\n        // In such situation we have to override entire array.\n        let $arraySet = {};\n        let $arrayUnset = {};\n        let $arrayPush = {};\n        // Compare up to number of elements in the array after the change.\n        _.each(newValue, function(newElement, index) {\n          const arrayPrefix = nestedPrefix + '.' + index;\n          const oldElement = oldValue[index];\n          if (!EJSON.equals(oldElement, newElement)) {\n            // If both array elements are object, then we perform diff between\n            // them.\n            if (_.isPlainObject(oldElement) && _.isPlainObject(newElement)) {\n              // Get a difference between elements.\n              let {\n                $set: $elementSet,\n                $unset: $elementUnset,\n                $push: $elementPush\n              } = diff({\n                oldDoc: oldElement,\n                newDoc: newElement,\n                prefix: arrayPrefix\n              });\n              _.extend($arraySet, $elementSet);\n              _.extend($arrayUnset, $elementUnset);\n              _.extend($arrayPush, $elementPush);\n            }\n            else {\n              $arraySet[arrayPrefix] = newElement;\n            }\n          }\n        });\n\n        // If an array was empty, then we override entire field with a new\n        // array. That way we solve a problem with treating array indexes as\n        // object keys, which cause inserting Object instead of Array into the\n        // Mongo collection.\n        if (oldValue.length === 0 && newValue.length > 0) {\n          $set[nestedPrefix] = newValue;\n        }\n        // Array length increased or stayed the same.\n        else if (newValue.length >= oldValue.length) {\n          _.extend($set, $arraySet);\n          _.extend($unset, $arrayUnset);\n          _.extend($push, $arrayPush);\n        }\n        // Array length decreased.\n        else {\n          // At least one array element has changed.\n          // FIXME: Due to an error in MiniMongo it's not possible to apply\n          // $push modifier with the $slice operator set to positive number.\n          // That's why the following \"if\" statement is always true and we\n          // have to override entire array when it was shrinked.\n          if (true || _.size($arraySet) > 0 || _.size($arrayPush) > 0) {\n            // So, we need to override entire array with its new state.\n            $set[nestedPrefix] = newValue;\n          }\n          // Array elements have not changed. The array length just shrinked.\n          else {\n            $push[nestedPrefix] = {\n              // We do not want to add any elements, we just want to slice an\n              // array.\n              $each: [],\n              // Slice array to new array length.\n              $slice: newValue.length\n            };\n          }\n        }\n\n      }\n      else {\n\n        if (newValue !== undefined) {\n          $set[nestedPrefix] = newValue;\n        }\n        else {\n          $unset[nestedPrefix] = '';\n        }\n      }\n    }\n  });\n\n  // Return only non empty modifiers.\n  let modifier = {};\n  if (_.size($set)) {\n    modifier.$set = $set;\n  }\n  if (_.size($unset)) {\n    modifier.$unset = $unset;\n  }\n  if (_.size($push)) {\n    modifier.$push = $push;\n  }\n  return modifier;\n};\n\nfunction getModifier(options) {\n  let {\n    doc: newDoc,\n    transient = false,\n    immutable = false,\n    fields\n  } = options;\n\n  const Class = newDoc.constructor;\n  const opts = {\n    defaults: false\n  };\n  const oldDoc = newDoc._isNew ?\n    new Class({}, opts) : Class.findOne(newDoc._id, opts);\n  // If there is no document before modifications that may mean that we are not\n  // subscribed to the publication publishing given document or we modified the\n  // _id of a document.\n  if (!oldDoc) {\n    throwParseError([{\n        'module': 'storage'\n      }, {\n        'utility': 'getModified'\n      },\n      `Can not get a document before modifications. You are not subscribed ` +\n      `to the publication publishing a \"${Class.getName()}\" document with ` +\n      `the id \"${newDoc._id}\" or you have modified the \"_id\" field`\n    ]);\n  }\n\n  // If there are not fields specified, then get all of them.\n  if (!fields) {\n    fields = Class.getFieldsNames();\n  }\n\n  return diff({\n    // Get raw data from the docs.\n    oldDoc: omitUndefined(rawMany(oldDoc, fields, {\n      transient,\n      immutable\n    })),\n    newDoc: omitUndefined(rawMany(newDoc, fields, {\n      transient,\n      immutable\n    }))\n  });\n};\n\nexport default getModifier;"]},"hash":"2387363148b2ac765f4be17281ae807b9911ac2e"}
