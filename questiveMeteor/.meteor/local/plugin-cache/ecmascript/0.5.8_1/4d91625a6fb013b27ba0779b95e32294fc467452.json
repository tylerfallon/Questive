{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"lodash","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_"}]},{"source":"./type.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Type"}]},{"source":"../validators/validators.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Validators"}]},{"source":"meteor/check","imported":["check","Match"],"specifiers":[{"kind":"named","imported":"check","local":"check"},{"kind":"named","imported":"Match","local":"Match"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/jagi:astronomy/lib/modules/fields/enum.js","filenameRelative":"/packages/jagi:astronomy/lib/modules/fields/enum.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/jagi:astronomy/lib/modules/fields/enum.js.map","sourceFileName":"/packages/jagi:astronomy/lib/modules/fields/enum.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"enum"},"ignored":false,"code":"var _;module.import('lodash',{\"default\":function(v){_=v}});var Type;module.import('./type.js',{\"default\":function(v){Type=v}});var Validators;module.import('../validators/validators.js',{\"default\":function(v){Validators=v}});var check,Match;module.import('meteor/check',{\"check\":function(v){check=v},\"Match\":function(v){Match=v}});\n\n\n\n\nvar enumDefinitionPattern = {\n  name: String,\n  identifiers: Match.OneOf(Array, Object)\n};\n\nvar Enum = {\n  create: function create(definition) {\n    check(definition, enumDefinitionPattern);\n\n    // Get identifiers and values.\n    var identifiers = void 0;\n    if (Match.test(definition.identifiers, Array)) {\n      identifiers = _.zipObject(definition.identifiers, _.range(definition.identifiers.length));\n    } else if (Match.test(definition.identifiers, Object)) {\n      (function () {\n        identifiers = definition.identifiers;\n        var i = 0;\n        _.forOwn(identifiers, function (value, key) {\n          if (_.isNil(value)) {\n            identifiers[key] = i;\n            i++;\n          } else if (_.isNumber(value)) {\n            i = value + 1;\n          }\n        });\n      })();\n    }\n    var values = _.values(identifiers);\n    var keys = _.keys(identifiers);\n    // Create a new Enum constructor.\n    var Enum = function Enum(identifier) {\n      return Enum[identifier];\n    };\n    Enum.getIdentifiers = function () {\n      return keys;\n    };\n    Enum.getIdentifier = function (value) {\n      var index = _.indexOf(values, value);\n      return keys[index];\n    };\n    // Set identifiers properties in the class.\n    _.each(identifiers, function (value, name) {\n      if (Object.defineProperty) {\n        Object.defineProperty(Enum, name, {\n          writable: false,\n          enumerable: true,\n          value: value\n        });\n      } else {\n        Enum[name] = value;\n      }\n    });\n    // Create type definition for the given enum.\n    Type.create({\n      name: definition.name,\n      'class': Enum,\n      validate: function validate(args) {\n        args.param = values;\n        Validators.choice(args);\n      }\n    });\n    // Store enum in the enums list.\n    this.enums[definition.name] = Enum;\n\n    return Enum;\n  },\n\n  enums: {}\n};\n\nmodule.export(\"default\",exports.default=(Enum));","ast":null,"map":{"version":3,"sources":["/packages/jagi:astronomy/lib/modules/fields/enum.js"],"names":[],"mappings":"AAAA,OAAO,CAAP,MAAc,QAAd;AACA,OAAO,IAAP,MAAiB,WAAjB;AACA,OAAO,UAAP,MAAuB,6BAAvB;AACA,SAAS,KAAT,EAAgB,KAAhB,QAA6B,cAA7B;;AAEA,IAAM,wBAAwB;AAC5B,QAAM,MADsB;AAE5B,eAAa,MAAM,KAAN,CAAY,KAAZ,EAAmB,MAAnB;AAFe,CAA9B;;AAKA,IAAM,OAAO;AACX,QADW,kBACJ,UADI,EACQ;AACjB,UAAM,UAAN,EAAkB,qBAAlB;;;AAGA,QAAI,oBAAJ;AACA,QAAI,MAAM,IAAN,CAAW,WAAW,WAAtB,EAAmC,KAAnC,CAAJ,EAA+C;AAC7C,oBAAc,EAAE,SAAF,CACZ,WAAW,WADC,EACY,EAAE,KAAF,CAAQ,WAAW,WAAX,CAAuB,MAA/B,CADZ,CAAd;AAGD,KAJD,MAKK,IAAI,MAAM,IAAN,CAAW,WAAW,WAAtB,EAAmC,MAAnC,CAAJ,EAAgD;AAAA;AACnD,sBAAc,WAAW,WAAzB;AACA,YAAI,IAAI,CAAR;AACA,UAAE,MAAF,CAAS,WAAT,EAAsB,UAAS,KAAT,EAAgB,GAAhB,EAAqB;AACzC,cAAI,EAAE,KAAF,CAAQ,KAAR,CAAJ,EAAoB;AAClB,wBAAY,GAAZ,IAAmB,CAAnB;AACA;AACD,WAHD,MAIK,IAAI,EAAE,QAAF,CAAW,KAAX,CAAJ,EAAuB;AAC1B,gBAAI,QAAQ,CAAZ;AACD;AACF,SARD;AAHmD;AAYpD;AACD,QAAM,SAAS,EAAE,MAAF,CAAS,WAAT,CAAf;AACA,QAAM,OAAO,EAAE,IAAF,CAAO,WAAP,CAAb;;AAEA,QAAM,OAAO,SAAS,IAAT,CAAc,UAAd,EAA0B;AACrC,aAAO,KAAK,UAAL,CAAP;AACD,KAFD;AAGA,SAAK,cAAL,GAAsB,YAAW;AAC/B,aAAO,IAAP;AACD,KAFD;AAGA,SAAK,aAAL,GAAqB,UAAS,KAAT,EAAgB;AACnC,UAAM,QAAQ,EAAE,OAAF,CAAU,MAAV,EAAkB,KAAlB,CAAd;AACA,aAAO,KAAK,KAAL,CAAP;AACD,KAHD;;AAKA,MAAE,IAAF,CAAO,WAAP,EAAoB,UAAC,KAAD,EAAQ,IAAR,EAAiB;AACnC,UAAI,OAAO,cAAX,EAA2B;AACzB,eAAO,cAAP,CAAsB,IAAtB,EAA4B,IAA5B,EAAkC;AAChC,oBAAU,KADsB;AAEhC,sBAAY,IAFoB;AAGhC;AAHgC,SAAlC;AAKD,OAND,MAOK;AACH,aAAK,IAAL,IAAa,KAAb;AACD;AACF,KAXD;;AAaA,SAAK,MAAL,CAAY;AACV,YAAM,WAAW,IADP;AAEV,eAAO,IAFG;AAGV,cAHU,oBAGD,IAHC,EAGK;AACb,aAAK,KAAL,GAAa,MAAb;AACA,mBAAW,MAAX,CAAkB,IAAlB;AACD;AANS,KAAZ;;AASA,SAAK,KAAL,CAAW,WAAW,IAAtB,IAA8B,IAA9B;;AAEA,WAAO,IAAP;AACD,GA/DU;;AAgEX,SAAO;AAhEI,CAAb;;AAmEA,eAAe,IAAf","file":"/packages/jagi:astronomy/lib/modules/fields/enum.js.map","sourcesContent":["import _ from 'lodash';\nimport Type from './type.js';\nimport Validators from '../validators/validators.js';\nimport { check, Match } from 'meteor/check';\n\nconst enumDefinitionPattern = {\n  name: String,\n  identifiers: Match.OneOf(Array, Object)\n};\n\nconst Enum = {\n  create(definition) {\n    check(definition, enumDefinitionPattern);\n\n    // Get identifiers and values.\n    let identifiers;\n    if (Match.test(definition.identifiers, Array)) {\n      identifiers = _.zipObject(\n        definition.identifiers, _.range(definition.identifiers.length)\n      );\n    }\n    else if (Match.test(definition.identifiers, Object)) {\n      identifiers = definition.identifiers;\n      let i = 0;\n      _.forOwn(identifiers, function(value, key) {\n        if (_.isNil(value)) {\n          identifiers[key] = i;\n          i++;\n        }\n        else if (_.isNumber(value)) {\n          i = value + 1;\n        }\n      });\n    }\n    const values = _.values(identifiers);\n    const keys = _.keys(identifiers);\n    // Create a new Enum constructor.\n    const Enum = function Enum(identifier) {\n      return Enum[identifier];\n    };\n    Enum.getIdentifiers = function() {\n      return keys;\n    };\n    Enum.getIdentifier = function(value) {\n      const index = _.indexOf(values, value);\n      return keys[index];\n    };\n    // Set identifiers properties in the class.\n    _.each(identifiers, (value, name) => {\n      if (Object.defineProperty) {\n        Object.defineProperty(Enum, name, {\n          writable: false,\n          enumerable: true,\n          value\n        });\n      }\n      else {\n        Enum[name] = value;\n      }\n    });\n    // Create type definition for the given enum.\n    Type.create({\n      name: definition.name,\n      class: Enum,\n      validate(args) {\n        args.param = values;\n        Validators.choice(args);\n      }\n    });\n    // Store enum in the enums list.\n    this.enums[definition.name] = Enum;\n\n    return Enum;\n  },\n  enums: {}\n};\n\nexport default Enum;"]},"hash":"4d91625a6fb013b27ba0779b95e32294fc467452"}
