{"metadata":{"usedHelpers":["toConsumableArray"],"marked":[],"modules":{"imports":[{"source":"lodash","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_"}]},{"source":"../../../core/class.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"AstroClass"}]},{"source":"../../core/utils/throw_parse_error.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"throwParseError"}]},{"source":"../../fields/utils/raw_many.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"rawMany"}]},{"source":"./omit_undefined.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"omitUndefined"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/jagi:astronomy/lib/modules/storage/utils/get_modified.js","filenameRelative":"/packages/jagi:astronomy/lib/modules/storage/utils/get_modified.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/jagi:astronomy/lib/modules/storage/utils/get_modified.js.map","sourceFileName":"/packages/jagi:astronomy/lib/modules/storage/utils/get_modified.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"get_modified"},"ignored":false,"code":"var _toConsumableArray;module.import('babel-runtime/helpers/toConsumableArray',{\"default\":function(v){_toConsumableArray=v}});var _;module.import('lodash',{\"default\":function(v){_=v}});var AstroClass;module.import('../../../core/class.js',{\"default\":function(v){AstroClass=v}});var throwParseError;module.import('../../core/utils/throw_parse_error.js',{\"default\":function(v){throwParseError=v}});var rawMany;module.import('../../fields/utils/raw_many.js',{\"default\":function(v){rawMany=v}});var omitUndefined;module.import('./omit_undefined.js',{\"default\":function(v){omitUndefined=v}});\n\n\n\n\n\n\nfunction diff(_ref) {\n  var newDoc = _ref.newDoc;\n  var oldDoc = _ref.oldDoc;\n  var _ref$prefix = _ref.prefix;\n  var prefix = _ref$prefix === undefined ? '' : _ref$prefix;\n\n  var result = [];\n\n  var fieldsNames = _.union(_.keys(oldDoc), _.keys(newDoc));\n  _.each(fieldsNames, function (fieldName) {\n    var oldValue = oldDoc[fieldName];\n    var newValue = newDoc[fieldName];\n\n    if (!EJSON.equals(oldValue, newValue)) {\n      (function () {\n        var nestedPrefix = (prefix && prefix + '.') + fieldName;\n        result.push(nestedPrefix);\n\n        // Compare two objects.\n        if (_.isPlainObject(oldValue) && _.isPlainObject(newValue)) {\n\n          result.push.apply(result, _toConsumableArray(diff({\n            oldDoc: oldValue,\n            newDoc: newValue,\n            prefix: nestedPrefix\n          })));\n        }\n        // Compare two arrays.\n        else if (_.isArray(oldValue) && _.isArray(newValue)) {\n\n            var maxLength = Math.max(oldValue.length, newValue.length);\n            _.each(_.range(maxLength), function (index) {\n              var arrayPrefix = nestedPrefix + '.' + index;\n              var oldElement = oldValue[index];\n              var newElement = newValue[index];\n              if (!EJSON.equals(oldElement, newElement)) {\n                result.push(arrayPrefix);\n                // If both array elements are object, then we perform diff between\n                // them.\n                if (_.isPlainObject(oldElement) && _.isPlainObject(newElement)) {\n                  // Get a difference between elements.\n                  result.push.apply(result, _toConsumableArray(diff({\n                    oldDoc: oldElement,\n                    newDoc: newElement,\n                    prefix: arrayPrefix\n                  })));\n                }\n              }\n            });\n          }\n      })();\n    }\n  });\n\n  return result;\n}\n\nfunction getModified() {\n  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n  var newDoc = options.doc;\n  var _options$transient = options.transient;\n  var transient = _options$transient === undefined ? false : _options$transient;\n  var _options$immutable = options.immutable;\n  var immutable = _options$immutable === undefined ? false : _options$immutable;\n  var fields = options.fields;\n\n\n  var Class = newDoc.constructor;\n  var opts = {\n    defaults: false\n  };\n  var oldDoc = newDoc._isNew ? new Class({}, opts) : Class.findOne(newDoc._id, opts);\n  // If there is no document before modifications that may mean that we are not\n  // subscribed to the publication publishing given document or we modified the\n  // _id of a document.\n  if (!oldDoc) {\n    throwParseError([{\n      'module': 'storage'\n    }, {\n      'utility': 'getModified'\n    }, 'Can not get a document before modifications. You are not subscribed ' + ('to the publication publishing a \"' + Class.getName() + '\" document with ') + ('the id \"' + newDoc._id + '\" or you have modified the \"_id\" field')]);\n  }\n\n  // If there are not fields specified, then get all of them.\n  if (!fields) {\n    fields = Class.getFieldsNames();\n  }\n\n  return diff({\n    // Get raw data from the docs.\n    oldDoc: omitUndefined(rawMany(oldDoc, fields, {\n      transient: transient,\n      immutable: immutable\n    })),\n    newDoc: omitUndefined(rawMany(newDoc, fields, {\n      transient: transient,\n      immutable: immutable\n    }))\n  });\n};\n\nmodule.export(\"default\",exports.default=(getModified));","ast":null,"map":{"version":3,"sources":["/packages/jagi:astronomy/lib/modules/storage/utils/get_modified.js"],"names":[],"mappings":";AAAA,OAAO,CAAP,MAAc,QAAd;AACA,OAAO,UAAP,MAAuB,wBAAvB;AACA,OAAO,eAAP,MAA4B,uCAA5B;AACA,OAAO,OAAP,MAAoB,gCAApB;AACA,OAAO,aAAP,MAA0B,qBAA1B;;AAEA,SAAS,IAAT,OAIG;AAAA,MAHD,MAGC,QAHD,MAGC;AAAA,MAFD,MAEC,QAFD,MAEC;AAAA,yBADD,MACC;AAAA,MADD,MACC,+BADQ,EACR;;AACD,MAAI,SAAS,EAAb;;AAEA,MAAM,cAAc,EAAE,KAAF,CAAQ,EAAE,IAAF,CAAO,MAAP,CAAR,EAAwB,EAAE,IAAF,CAAO,MAAP,CAAxB,CAApB;AACA,IAAE,IAAF,CAAO,WAAP,EAAoB,UAAS,SAAT,EAAoB;AACtC,QAAM,WAAW,OAAO,SAAP,CAAjB;AACA,QAAM,WAAW,OAAO,SAAP,CAAjB;;AAEA,QAAI,CAAC,MAAM,MAAN,CAAa,QAAb,EAAuB,QAAvB,CAAL,EAAuC;AAAA;AACrC,YAAM,eAAe,CAAC,UAAU,SAAS,GAApB,IAA2B,SAAhD;AACA,eAAO,IAAP,CAAY,YAAZ;;;AAGA,YAAI,EAAE,aAAF,CAAgB,QAAhB,KAA6B,EAAE,aAAF,CAAgB,QAAhB,CAAjC,EAA4D;;AAE1D,iBAAO,IAAP,kCAAe,KAAK;AAClB,oBAAQ,QADU;AAElB,oBAAQ,QAFU;AAGlB,oBAAQ;AAHU,WAAL,CAAf;AAMD;;AARD,aAUK,IAAI,EAAE,OAAF,CAAU,QAAV,KAAuB,EAAE,OAAF,CAAU,QAAV,CAA3B,EAAgD;;AAEnD,gBAAI,YAAY,KAAK,GAAL,CAAS,SAAS,MAAlB,EAA0B,SAAS,MAAnC,CAAhB;AACA,cAAE,IAAF,CAAO,EAAE,KAAF,CAAQ,SAAR,CAAP,EAA2B,UAAS,KAAT,EAAgB;AACzC,kBAAM,cAAc,eAAe,GAAf,GAAqB,KAAzC;AACA,kBAAM,aAAa,SAAS,KAAT,CAAnB;AACA,kBAAM,aAAa,SAAS,KAAT,CAAnB;AACA,kBAAI,CAAC,MAAM,MAAN,CAAa,UAAb,EAAyB,UAAzB,CAAL,EAA2C;AACzC,uBAAO,IAAP,CAAY,WAAZ;;;AAGA,oBAAI,EAAE,aAAF,CAAgB,UAAhB,KAA+B,EAAE,aAAF,CAAgB,UAAhB,CAAnC,EAAgE;;AAE9D,yBAAO,IAAP,kCAAe,KAAK;AAClB,4BAAQ,UADU;AAElB,4BAAQ,UAFU;AAGlB,4BAAQ;AAHU,mBAAL,CAAf;AAKD;AACF;AACF,aAjBD;AAmBD;AArCoC;AAsCtC;AACF,GA3CD;;AA6CA,SAAO,MAAP;AACD;;AAED,SAAS,WAAT,GAAmC;AAAA,MAAd,OAAc,yDAAJ,EAAI;AAAA,MAE1B,MAF0B,GAM7B,OAN6B,CAE/B,GAF+B;AAAA,2BAM7B,OAN6B,CAG/B,SAH+B;AAAA,MAG/B,SAH+B,sCAGnB,KAHmB;AAAA,2BAM7B,OAN6B,CAI/B,SAJ+B;AAAA,MAI/B,SAJ+B,sCAInB,KAJmB;AAAA,MAK/B,MAL+B,GAM7B,OAN6B,CAK/B,MAL+B;;;AAQjC,MAAM,QAAQ,OAAO,WAArB;AACA,MAAM,OAAO;AACX,cAAU;AADC,GAAb;AAGA,MAAM,SAAS,OAAO,MAAP,GACb,IAAI,KAAJ,CAAU,EAAV,EAAc,IAAd,CADa,GACS,MAAM,OAAN,CAAc,OAAO,GAArB,EAA0B,IAA1B,CADxB;;;;AAKA,MAAI,CAAC,MAAL,EAAa;AACX,oBAAgB,CAAC;AACb,gBAAU;AADG,KAAD,EAEX;AACD,iBAAW;AADV,KAFW,EAKd,gHACoC,MAAM,OAAN,EADpC,uCAEW,OAAO,GAFlB,4CALc,CAAhB;AASD;;;AAGD,MAAI,CAAC,MAAL,EAAa;AACX,aAAS,MAAM,cAAN,EAAT;AACD;;AAED,SAAO,KAAK;;AAEV,YAAQ,cAAc,QAAQ,MAAR,EAAgB,MAAhB,EAAwB;AAC5C,0BAD4C;AAE5C;AAF4C,KAAxB,CAAd,CAFE;AAMV,YAAQ,cAAc,QAAQ,MAAR,EAAgB,MAAhB,EAAwB;AAC5C,0BAD4C;AAE5C;AAF4C,KAAxB,CAAd;AANE,GAAL,CAAP;AAWD;;AAED,eAAe,WAAf","file":"/packages/jagi:astronomy/lib/modules/storage/utils/get_modified.js.map","sourcesContent":["import _ from 'lodash';\nimport AstroClass from '../../../core/class.js';\nimport throwParseError from '../../core/utils/throw_parse_error.js';\nimport rawMany from '../../fields/utils/raw_many.js';\nimport omitUndefined from './omit_undefined.js';\n\nfunction diff({\n  newDoc,\n  oldDoc,\n  prefix = ''\n}) {\n  let result = [];\n\n  const fieldsNames = _.union(_.keys(oldDoc), _.keys(newDoc));\n  _.each(fieldsNames, function(fieldName) {\n    const oldValue = oldDoc[fieldName];\n    const newValue = newDoc[fieldName];\n\n    if (!EJSON.equals(oldValue, newValue)) {\n      const nestedPrefix = (prefix && prefix + '.') + fieldName;\n      result.push(nestedPrefix);\n\n      // Compare two objects.\n      if (_.isPlainObject(oldValue) && _.isPlainObject(newValue)) {\n\n        result.push(...diff({\n          oldDoc: oldValue,\n          newDoc: newValue,\n          prefix: nestedPrefix\n        }));\n\n      }\n      // Compare two arrays.\n      else if (_.isArray(oldValue) && _.isArray(newValue)) {\n\n        let maxLength = Math.max(oldValue.length, newValue.length);\n        _.each(_.range(maxLength), function(index) {\n          const arrayPrefix = nestedPrefix + '.' + index;\n          const oldElement = oldValue[index];\n          const newElement = newValue[index];\n          if (!EJSON.equals(oldElement, newElement)) {\n            result.push(arrayPrefix);\n            // If both array elements are object, then we perform diff between\n            // them.\n            if (_.isPlainObject(oldElement) && _.isPlainObject(newElement)) {\n              // Get a difference between elements.\n              result.push(...diff({\n                oldDoc: oldElement,\n                newDoc: newElement,\n                prefix: arrayPrefix\n              }));\n            }\n          }\n        });\n\n      }\n    }\n  });\n\n  return result;\n}\n\nfunction getModified(options = {}) {\n  let {\n    doc: newDoc,\n    transient = false,\n    immutable = false,\n    fields\n  } = options;\n\n  const Class = newDoc.constructor;\n  const opts = {\n    defaults: false\n  };\n  const oldDoc = newDoc._isNew ?\n    new Class({}, opts) : Class.findOne(newDoc._id, opts);\n  // If there is no document before modifications that may mean that we are not\n  // subscribed to the publication publishing given document or we modified the\n  // _id of a document.\n  if (!oldDoc) {\n    throwParseError([{\n        'module': 'storage'\n      }, {\n        'utility': 'getModified'\n      },\n      `Can not get a document before modifications. You are not subscribed ` +\n      `to the publication publishing a \"${Class.getName()}\" document with ` +\n      `the id \"${newDoc._id}\" or you have modified the \"_id\" field`\n    ]);\n  }\n\n  // If there are not fields specified, then get all of them.\n  if (!fields) {\n    fields = Class.getFieldsNames();\n  }\n\n  return diff({\n    // Get raw data from the docs.\n    oldDoc: omitUndefined(rawMany(oldDoc, fields, {\n      transient,\n      immutable\n    })),\n    newDoc: omitUndefined(rawMany(newDoc, fields, {\n      transient,\n      immutable\n    }))\n  });\n};\n\nexport default getModified;"]},"hash":"8e52f6b808a9520972cf06f35d46f887ad45c613"}
