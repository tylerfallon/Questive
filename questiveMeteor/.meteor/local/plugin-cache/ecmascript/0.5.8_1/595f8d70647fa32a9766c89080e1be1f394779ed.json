{"metadata":{"usedHelpers":["classCallCheck","inherits","possibleConstructorReturn"],"marked":[],"modules":{"imports":[{"source":"lodash","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_"}]},{"source":"meteor/ejson","imported":["EJSON"],"specifiers":[{"kind":"named","imported":"EJSON","local":"EJSON"}]},{"source":"../modules/core/utils/throw_parse_error.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"throwParseError"}]},{"source":"../modules/core/utils/clone_definition.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"cloneDefinition"}]},{"source":"../modules/fields/utils/set_defaults.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"setDefaults"}]},{"source":"../modules/fields/utils/cast_nested.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"castNested"}]},{"source":"./module.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Module"}]},{"source":"../modules/events/event.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Event"}]},{"source":"../modules/fields/type.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Type"}]},{"source":"../modules/validators/validators.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Validators"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/jagi:astronomy/lib/core/class.js","filenameRelative":"/packages/jagi:astronomy/lib/core/class.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/jagi:astronomy/lib/core/class.js.map","sourceFileName":"/packages/jagi:astronomy/lib/core/class.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"class"},"ignored":false,"code":"var _possibleConstructorReturn;module.import('babel-runtime/helpers/possibleConstructorReturn',{\"default\":function(v){_possibleConstructorReturn=v}});var _inherits;module.import('babel-runtime/helpers/inherits',{\"default\":function(v){_inherits=v}});var _classCallCheck;module.import('babel-runtime/helpers/classCallCheck',{\"default\":function(v){_classCallCheck=v}});var _;module.import('lodash',{\"default\":function(v){_=v}});var EJSON;module.import('meteor/ejson',{\"EJSON\":function(v){EJSON=v}});var throwParseError;module.import('../modules/core/utils/throw_parse_error.js',{\"default\":function(v){throwParseError=v}});var cloneDefinition;module.import('../modules/core/utils/clone_definition.js',{\"default\":function(v){cloneDefinition=v}});var setDefaults;module.import('../modules/fields/utils/set_defaults.js',{\"default\":function(v){setDefaults=v}});var castNested;module.import('../modules/fields/utils/cast_nested.js',{\"default\":function(v){castNested=v}});var Module;module.import('./module.js',{\"default\":function(v){Module=v}});var Event;module.import('../modules/events/event.js',{\"default\":function(v){Event=v}});var Type;module.import('../modules/fields/type.js',{\"default\":function(v){Type=v}});var Validators;module.import('../modules/validators/validators.js',{\"default\":function(v){Validators=v}});\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar initClass = function initClass(Class) {\n  // Create and store the schema \"definition\" object in the class constructor.\n  // It's a combination of all parent definitions and a definition that\n  // created this class. It's used to create child classes.\n  Class.definition = {};\n  // Create and store the \"schema\" object in the class constructor. It's an\n  // object that contains all the data related with a given class. The\n  // \"schema\" object contains \"computed\" data of the schema \"definition\".\n  // Thanks to that, Astronomy does not need to compute data on the fly and\n  // everything works faster.\n  Class.schema = {};\n  // Create empty array for storing child classes.\n  Class.children = [];\n  // Init the class schema and schema definition.\n  Module.forEach(function (module) {\n    module.onInitSchema(Class.schema, Class.getName());\n    module.onInitDefinition(Class.definition, Class.getName());\n  });\n  // We have to call the \"onInitClass\" hooks in the separate loop after\n  // initiation of the schema and schema definition, because some\n  // \"onInitClass\" hooks can execute the \"Class.extend\" method which requires\n  // schema and schama definition to be initalized.\n  Module.forEach(function (module) {\n    module.onInitClass(Class, Class.getName());\n  });\n};\n\n// Helper variables for passing information about options to nested documents\n// being initialised during construction.\nvar callsCount = 0;\nvar cloneArgs = null;\n\nvar Class = function () {\n  function Class(rawDoc) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Class);\n\n    // Set default options.\n    _.defaults(options, {\n      defaults: true,\n      clone: true\n    });\n\n    if (callsCount === 0 && cloneArgs === null) {\n      cloneArgs = options.clone;\n    }\n    callsCount++;\n\n    var doc = this;\n    var _Class = doc.constructor;\n\n    if (!_Class.getName()) {\n      throw new Error('Can not create instance of the \"Astro.Class\" class');\n    }\n\n    // Trigger the \"beforeInit\" event handlers.\n    doc.dispatchEvent(new Event('beforeInit'));\n\n    // Clone an argument if the \"clone\" option is set.\n    rawDoc = rawDoc || {};\n    if (cloneArgs) {\n      rawDoc = EJSON.clone(rawDoc);\n    }\n\n    // Set values in a document.\n    var fields = _Class.getFields();\n    _.each(fields, function (field) {\n      doc[field.name] = rawDoc[field.name];\n    });\n\n    // Set default values if the \"defaults\" option is set.\n    if (options.defaults) {\n      setDefaults({\n        doc: doc\n      });\n    }\n    // Cast nested documents.\n    castNested({\n      doc: doc,\n      options: {\n        clone: options.clone\n      }\n    });\n\n    // Trigger the \"afterInit\" event handlers.\n    doc.dispatchEvent(new Event('afterInit'));\n\n    // Decrease number of nested documents being initialised.\n    if (callsCount > 0) {\n      callsCount--;\n    }\n    if (callsCount === 0) {\n      cloneArgs = null;\n    }\n  }\n\n  // Method needed for EJSONification.\n\n\n  Class.prototype.typeName = function () {\n    function typeName() {\n      return 'Astronomy';\n    }\n\n    return typeName;\n  }();\n\n  Class.prototype.toJSONValue = function () {\n    function toJSONValue(args) {\n      var doc = this;\n      var Class = doc.constructor;\n\n      var json = {\n        'class': Class.getName()\n      };\n\n      // Trigger the \"toJSONValue\" event handlers.\n      doc.dispatchEvent(new Event('toJSONValue', {\n        json: json\n      }));\n\n      return json;\n    }\n\n    return toJSONValue;\n  }();\n\n  Class.getName = function () {\n    function getName() {\n      return this.className;\n    }\n\n    return getName;\n  }();\n\n  Class.getParent = function () {\n    function getParent() {\n      if (this.parentClassName) {\n        return this.get(this.parentClassName);\n      }\n    }\n\n    return getParent;\n  }();\n\n  Class.getChildren = function () {\n    function getChildren() {\n      return this.children;\n    }\n\n    return getChildren;\n  }();\n\n  Class.create = function () {\n    function create(definition) {\n      // Get class name.\n      var className = definition.name;\n      // Extend the Astro.Class class.\n      var Class = this.classes[className] = function (_ref) {\n        _inherits(Class, _ref);\n\n        function Class() {\n          _classCallCheck(this, Class);\n\n          return _possibleConstructorReturn(this, _ref.apply(this, arguments));\n        }\n\n        return Class;\n      }(this);\n      // Store the class name in the constructor.\n      Class.className = className;\n      // Initialize class.\n      initClass(Class);\n      // Extend class with a definition.\n      Class.extend(definition);\n      // Register a new type.\n      Type.create({\n        name: className,\n        'class': Class,\n        validate: function () {\n          function validate(args) {\n            // Add current class as a param of validator.\n            args.param = Class;\n            Validators['class'](args);\n          }\n\n          return validate;\n        }()\n      });\n\n      return Class;\n    }\n\n    return create;\n  }();\n\n  Class.inherit = function () {\n    function inherit(definition) {\n      var Parent = this;\n      var className = definition.name;\n\n      // Extend the parent class.\n      var Class = this.classes[className] = function (_Parent) {\n        _inherits(Class, _Parent);\n\n        function Class() {\n          _classCallCheck(this, Class);\n\n          return _possibleConstructorReturn(this, _Parent.apply(this, arguments));\n        }\n\n        return Class;\n      }(Parent);\n\n      // Store the class name in the constructor.\n      Class.className = className;\n      // Store the parent class name in the constructor.\n      Class.parentClassName = Parent.getName();\n      // Initialize class.\n      initClass(Class);\n      // Store child class in the parent class.\n      Parent.children.push(Class);\n      // Extend class with the parent class definition.\n      Class.extend(Parent.definition);\n      // Extend class with the definition.\n      Class.extend(definition);\n      // Register a new type.\n      Type.create({\n        name: className,\n        'class': Class,\n        validate: function () {\n          function validate(args) {\n            // Add current class as a param of validator.\n            args.param = Class;\n            Validators['class'](args);\n          }\n\n          return validate;\n        }()\n      });\n\n      return Class;\n    }\n\n    return inherit;\n  }();\n\n  Class.extend = function () {\n    function extend(extendDefinition, onlyModules) {\n      var _this3 = this;\n\n      if (onlyModules !== undefined && !Match.test(onlyModules, Match.OneOf(String, [String]))) {\n        throwParseError([{\n          'class': this.getName()\n        }, {\n          'method': 'extend'\n        }, 'The second argument has to be a string or an array of strings']);\n      }\n\n      if (Match.test(onlyModules, String)) {\n        onlyModules = [onlyModules];\n      }\n\n      // Clone definition to not modify the original one.\n      extendDefinition = cloneDefinition(extendDefinition);\n\n      Module.forEach(function (module) {\n        // If the second argument was passed, then we only run module hooks for\n        // modules that were listed in the second argument.\n        if (onlyModules !== undefined && !_.includes(onlyModules, module.name)) {\n          return;\n        }\n        // Initialize parsed definition.\n        var parsedDefinition = {};\n        module.onInitDefinition(parsedDefinition, Class.getName());\n        // Parse the extending definition and put parsed properties in the parsed\n        // definition.\n        module.onParseDefinition(parsedDefinition, extendDefinition, _this3.getName());\n        // Apply parsed definition.\n        module.onApplyDefinition(_this3, parsedDefinition, _this3.getName());\n        // Merge parsed definition with a class definition.\n        module.onMergeDefinitions(_this3.definition, parsedDefinition, _this3.getName());\n      });\n    }\n\n    return extend;\n  }();\n\n  Class.get = function () {\n    function get(className) {\n      return this.classes[className];\n    }\n\n    return get;\n  }();\n\n  Class.has = function () {\n    function has(className) {\n      return _.has(this.classes, className);\n    }\n\n    return has;\n  }();\n\n  Class.includes = function () {\n    function includes(Class) {\n      return _.includes(this.classes, Class);\n    }\n\n    return includes;\n  }();\n\n  Class.isParentOf = function () {\n    function isParentOf(Class) {\n      if (!Class || !Class.prototype) {\n        return false;\n      }\n      return this.prototype.isPrototypeOf(Class.prototype);\n    }\n\n    return isParentOf;\n  }();\n\n  Class.isChildOf = function () {\n    function isChildOf(Class) {\n      if (!Class || !Class.prototype) {\n        return false;\n      }\n      return Class.prototype.isPrototypeOf(this.prototype);\n    }\n\n    return isChildOf;\n  }();\n\n  return Class;\n}();\n\n;\n\nClass.classes = {};\n\nmodule.export(\"default\",exports.default=(Class));","ast":null,"map":{"version":3,"sources":["/packages/jagi:astronomy/lib/core/class.js"],"names":[],"mappings":"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","file":"/packages/jagi:astronomy/lib/core/class.js.map","sourcesContent":["import _ from 'lodash';\nimport { EJSON } from 'meteor/ejson';\nimport throwParseError from '../modules/core/utils/throw_parse_error.js';\nimport cloneDefinition from '../modules/core/utils/clone_definition.js';\nimport setDefaults from '../modules/fields/utils/set_defaults.js';\nimport castNested from '../modules/fields/utils/cast_nested.js';\nimport Module from './module.js';\nimport Event from '../modules/events/event.js';\nimport Type from '../modules/fields/type.js';\nimport Validators from '../modules/validators/validators.js';\n\nlet initClass = function(Class) {\n  // Create and store the schema \"definition\" object in the class constructor.\n  // It's a combination of all parent definitions and a definition that\n  // created this class. It's used to create child classes.\n  Class.definition = {};\n  // Create and store the \"schema\" object in the class constructor. It's an\n  // object that contains all the data related with a given class. The\n  // \"schema\" object contains \"computed\" data of the schema \"definition\".\n  // Thanks to that, Astronomy does not need to compute data on the fly and\n  // everything works faster.\n  Class.schema = {};\n  // Create empty array for storing child classes.\n  Class.children = [];\n  // Init the class schema and schema definition.\n  Module.forEach((module) => {\n    module.onInitSchema(Class.schema, Class.getName());\n    module.onInitDefinition(Class.definition, Class.getName());\n  });\n  // We have to call the \"onInitClass\" hooks in the separate loop after\n  // initiation of the schema and schema definition, because some\n  // \"onInitClass\" hooks can execute the \"Class.extend\" method which requires\n  // schema and schama definition to be initalized.\n  Module.forEach((module) => {\n    module.onInitClass(Class, Class.getName());\n  });\n};\n\n// Helper variables for passing information about options to nested documents\n// being initialised during construction.\nlet callsCount = 0;\nlet cloneArgs = null;\n\nclass Class {\n  constructor(rawDoc, options = {}) {\n    // Set default options.\n    _.defaults(options, {\n      defaults: true,\n      clone: true\n    });\n\n    if (callsCount === 0 && cloneArgs === null) {\n      cloneArgs = options.clone;\n    }\n    callsCount++;\n\n    const doc = this;\n    const Class = doc.constructor;\n\n    if (!Class.getName()) {\n      throw new Error(\n        'Can not create instance of the \"Astro.Class\" class'\n      );\n    }\n\n    // Trigger the \"beforeInit\" event handlers.\n    doc.dispatchEvent(new Event('beforeInit'));\n\n    // Clone an argument if the \"clone\" option is set.\n    rawDoc = rawDoc || {};\n    if (cloneArgs) {\n      rawDoc = EJSON.clone(rawDoc);\n    }\n\n    // Set values in a document.\n    const fields = Class.getFields();\n    _.each(fields, (field) => {\n      doc[field.name] = rawDoc[field.name];\n    });\n\n    // Set default values if the \"defaults\" option is set.\n    if (options.defaults) {\n      setDefaults({\n        doc\n      });\n    }\n    // Cast nested documents.\n    castNested({\n      doc,\n      options: {\n        clone: options.clone\n      }\n    });\n\n    // Trigger the \"afterInit\" event handlers.\n    doc.dispatchEvent(new Event('afterInit'));\n\n    // Decrease number of nested documents being initialised.\n    if (callsCount > 0) {\n      callsCount--;\n    }\n    if (callsCount === 0) {\n      cloneArgs = null;\n    }\n  }\n\n  // Method needed for EJSONification.\n  typeName() {\n    return 'Astronomy';\n  }\n\n  toJSONValue(args) {\n    let doc = this;\n    let Class = doc.constructor;\n\n    let json = {\n      class: Class.getName()\n    };\n\n    // Trigger the \"toJSONValue\" event handlers.\n    doc.dispatchEvent(new Event('toJSONValue', {\n      json: json\n    }));\n\n    return json;\n  }\n\n  static getName() {\n    return this.className;\n  }\n\n  static getParent() {\n    if (this.parentClassName) {\n      return this.get(this.parentClassName);\n    }\n  }\n\n  static getChildren() {\n    return this.children;\n  }\n\n  static create(definition) {\n    // Get class name.\n    let className = definition.name;\n    // Extend the Astro.Class class.\n    let Class = this.classes[className] = class Class extends this {};\n    // Store the class name in the constructor.\n    Class.className = className;\n    // Initialize class.\n    initClass(Class);\n    // Extend class with a definition.\n    Class.extend(definition);\n    // Register a new type.\n    Type.create({\n      name: className,\n      class: Class,\n      validate(args) {\n        // Add current class as a param of validator.\n        args.param = Class;\n        Validators.class(args);\n      }\n    });\n\n    return Class;\n  }\n\n  static inherit(definition) {\n    const Parent = this;\n    const className = definition.name;\n\n    // Extend the parent class.\n    const Class = this.classes[className] = class Class extends Parent {};\n\n    // Store the class name in the constructor.\n    Class.className = className;\n    // Store the parent class name in the constructor.\n    Class.parentClassName = Parent.getName();\n    // Initialize class.\n    initClass(Class);\n    // Store child class in the parent class.\n    Parent.children.push(Class);\n    // Extend class with the parent class definition.\n    Class.extend(Parent.definition);\n    // Extend class with the definition.\n    Class.extend(definition);\n    // Register a new type.\n    Type.create({\n      name: className,\n      class: Class,\n      validate(args) {\n        // Add current class as a param of validator.\n        args.param = Class;\n        Validators.class(args);\n      }\n    });\n\n    return Class;\n  }\n\n  static extend(extendDefinition, onlyModules) {\n    if (\n      onlyModules !== undefined &&\n      !Match.test(onlyModules, Match.OneOf(String, [String]))\n    ) {\n      throwParseError([{\n          'class': this.getName()\n        }, {\n          'method': 'extend'\n        },\n        'The second argument has to be a string or an array of strings'\n      ]);\n    }\n\n    if (Match.test(onlyModules, String)) {\n      onlyModules = [onlyModules];\n    }\n\n    // Clone definition to not modify the original one.\n    extendDefinition = cloneDefinition(extendDefinition);\n\n    Module.forEach((module) => {\n      // If the second argument was passed, then we only run module hooks for\n      // modules that were listed in the second argument.\n      if (onlyModules !== undefined && !_.includes(onlyModules, module.name)) {\n        return;\n      }\n      // Initialize parsed definition.\n      let parsedDefinition = {};\n      module.onInitDefinition(parsedDefinition, Class.getName());\n      // Parse the extending definition and put parsed properties in the parsed\n      // definition.\n      module.onParseDefinition(parsedDefinition, extendDefinition, this.getName());\n      // Apply parsed definition.\n      module.onApplyDefinition(this, parsedDefinition, this.getName());\n      // Merge parsed definition with a class definition.\n      module.onMergeDefinitions(this.definition, parsedDefinition, this.getName());\n    });\n  }\n\n  static get(className) {\n    return this.classes[className];\n  }\n\n  static has(className) {\n    return _.has(this.classes, className);\n  }\n\n  static includes(Class) {\n    return _.includes(this.classes, Class);\n  }\n\n  static isParentOf(Class) {\n    if (!Class || !Class.prototype) {\n      return false;\n    }\n    return this.prototype.isPrototypeOf(Class.prototype);\n  }\n\n  static isChildOf(Class) {\n    if (!Class || !Class.prototype) {\n      return false;\n    }\n    return Class.prototype.isPrototypeOf(this.prototype);\n  }\n};\n\nClass.classes = {};\n\nexport default Class;"]},"hash":"595f8d70647fa32a9766c89080e1be1f394779ed"}
