{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"lodash","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_"}]},{"source":"../../core/utils/throw_parse_error.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"throwParseError"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/jagi:astronomy/lib/modules/storage/hooks/parse_definition.js","filenameRelative":"/packages/jagi:astronomy/lib/modules/storage/hooks/parse_definition.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/jagi:astronomy/lib/modules/storage/hooks/parse_definition.js.map","sourceFileName":"/packages/jagi:astronomy/lib/modules/storage/hooks/parse_definition.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"parse_definition"},"ignored":false,"code":"var _;module.import('lodash',{\"default\":function(v){_=v}});var throwParseError;module.import('../../core/utils/throw_parse_error.js',{\"default\":function(v){throwParseError=v}});\n\n\nfunction onParseDefinition(parsedDefinition, definition, className) {\n  // Check existence and validity of the \"collection\" property.\n  if (definition.collection !== undefined) {\n    // The \"collection\" property has to be an instance of the\n    // \"Mongo.Collection\".\n    if (!(definition.collection instanceof Mongo.Collection)) {\n      throwParseError([{\n        'class': className\n      }, {\n        'property': 'collection'\n      }, 'Property value has to be an instance of \"Mongo.Collection\"']);\n    }\n    parsedDefinition.collection = definition.collection;\n  }\n\n  // Check existence and validity of the \"typeField\" property.\n  if (definition.typeField !== undefined) {\n    // The \"typeField\" property has to be a string.\n    if (!Match.test(definition.typeField, String)) {\n      throwParseError([{\n        'class': className\n      }, {\n        'property': 'typeField'\n      }, 'Property value has to be a string']);\n    }\n    parsedDefinition.typeField = definition.typeField;\n  }\n\n  // Check existence and validity of the \"transform\" property.\n  if (definition.transform !== undefined) {\n    // The \"transform\" property has to be a function.\n    if (!Match.test(definition.transform, Match.OneOf(Function, null))) {\n      throwParseError([{\n        'class': className\n      }, {\n        'property': 'transform'\n      }, 'Property value has to be a function or null']);\n    }\n    parsedDefinition.transform = definition.transform;\n  }\n\n  // Check existence and validity of the \"secured\" property.\n  if (definition.secured !== undefined) {\n    if (!Match.test(definition.secured, Match.OneOf(Boolean, Object))) {\n      throwParseError([{\n        'class': className\n      }, {\n        'property': 'secured'\n      }, 'Property value has to be a boolean or an object with keys being ' + 'method name and values being boolean']);\n    }\n    if (_.isBoolean(definition.secured)) {\n      parsedDefinition.secured = {\n        common: definition.secured\n      };\n    } else {\n      parsedDefinition.secured = definition.secured;\n    }\n  }\n};\n\nmodule.export(\"default\",exports.default=(onParseDefinition));","ast":null,"map":{"version":3,"sources":["/packages/jagi:astronomy/lib/modules/storage/hooks/parse_definition.js"],"names":[],"mappings":"AAAA,OAAO,CAAP,MAAc,QAAd;AACA,OAAO,eAAP,MAA4B,uCAA5B;;AAEA,SAAS,iBAAT,CAA2B,gBAA3B,EAA6C,UAA7C,EAAyD,SAAzD,EAAoE;;AAElE,MAAI,WAAW,UAAX,KAA0B,SAA9B,EAAyC;;;AAGvC,QAAI,EAAE,WAAW,UAAX,YAAiC,MAAM,UAAzC,CAAJ,EAA0D;AACxD,sBAAgB,CAAC;AACb,iBAAS;AADI,OAAD,EAEX;AACD,oBAAY;AADX,OAFW,EAKd,4DALc,CAAhB;AAOD;AACD,qBAAiB,UAAjB,GAA8B,WAAW,UAAzC;AACD;;;AAGD,MAAI,WAAW,SAAX,KAAyB,SAA7B,EAAwC;;AAEtC,QAAI,CAAC,MAAM,IAAN,CAAW,WAAW,SAAtB,EAAiC,MAAjC,CAAL,EAA+C;AAC7C,sBAAgB,CAAC;AACb,iBAAS;AADI,OAAD,EAEX;AACD,oBAAY;AADX,OAFW,EAKd,mCALc,CAAhB;AAOD;AACD,qBAAiB,SAAjB,GAA6B,WAAW,SAAxC;AACD;;;AAGD,MAAI,WAAW,SAAX,KAAyB,SAA7B,EAAwC;;AAEtC,QAAI,CAAC,MAAM,IAAN,CAAW,WAAW,SAAtB,EAAiC,MAAM,KAAN,CAAY,QAAZ,EAAsB,IAAtB,CAAjC,CAAL,EAAoE;AAClE,sBAAgB,CAAC;AACb,iBAAS;AADI,OAAD,EAEX;AACD,oBAAY;AADX,OAFW,EAKd,6CALc,CAAhB;AAOD;AACD,qBAAiB,SAAjB,GAA6B,WAAW,SAAxC;AACD;;;AAGD,MAAI,WAAW,OAAX,KAAuB,SAA3B,EAAsC;AACpC,QAAI,CAAC,MAAM,IAAN,CAAW,WAAW,OAAtB,EAA+B,MAAM,KAAN,CAAY,OAAZ,EAAqB,MAArB,CAA/B,CAAL,EAAmE;AACjE,sBAAgB,CAAC;AACb,iBAAS;AADI,OAAD,EAEX;AACD,oBAAY;AADX,OAFW,EAKd,qEACA,sCANc,CAAhB;AAQD;AACD,QAAI,EAAE,SAAF,CAAY,WAAW,OAAvB,CAAJ,EAAqC;AACnC,uBAAiB,OAAjB,GAA2B;AACzB,gBAAQ,WAAW;AADM,OAA3B;AAGD,KAJD,MAKK;AACH,uBAAiB,OAAjB,GAA2B,WAAW,OAAtC;AACD;AACF;AACF;;AAED,eAAe,iBAAf","file":"/packages/jagi:astronomy/lib/modules/storage/hooks/parse_definition.js.map","sourcesContent":["import _ from 'lodash';\nimport throwParseError from '../../core/utils/throw_parse_error.js';\n\nfunction onParseDefinition(parsedDefinition, definition, className) {\n  // Check existence and validity of the \"collection\" property.\n  if (definition.collection !== undefined) {\n    // The \"collection\" property has to be an instance of the\n    // \"Mongo.Collection\".\n    if (!(definition.collection instanceof Mongo.Collection)) {\n      throwParseError([{\n          'class': className\n        }, {\n          'property': 'collection'\n        },\n        'Property value has to be an instance of \"Mongo.Collection\"'\n      ]);\n    }\n    parsedDefinition.collection = definition.collection;\n  }\n\n  // Check existence and validity of the \"typeField\" property.\n  if (definition.typeField !== undefined) {\n    // The \"typeField\" property has to be a string.\n    if (!Match.test(definition.typeField, String)) {\n      throwParseError([{\n          'class': className\n        }, {\n          'property': 'typeField'\n        },\n        'Property value has to be a string'\n      ]);\n    }\n    parsedDefinition.typeField = definition.typeField;\n  }\n\n  // Check existence and validity of the \"transform\" property.\n  if (definition.transform !== undefined) {\n    // The \"transform\" property has to be a function.\n    if (!Match.test(definition.transform, Match.OneOf(Function, null))) {\n      throwParseError([{\n          'class': className\n        }, {\n          'property': 'transform'\n        },\n        'Property value has to be a function or null'\n      ]);\n    }\n    parsedDefinition.transform = definition.transform;\n  }\n\n  // Check existence and validity of the \"secured\" property.\n  if (definition.secured !== undefined) {\n    if (!Match.test(definition.secured, Match.OneOf(Boolean, Object))) {\n      throwParseError([{\n          'class': className\n        }, {\n          'property': 'secured'\n        },\n        'Property value has to be a boolean or an object with keys being ' +\n        'method name and values being boolean'\n      ]);\n    }\n    if (_.isBoolean(definition.secured)) {\n      parsedDefinition.secured = {\n        common: definition.secured\n      };\n    }\n    else {\n      parsedDefinition.secured = definition.secured;\n    }\n  }\n};\n\nexport default onParseDefinition;"]},"hash":"f05e4fbc4e670e2aee0dacf1d062bdb7b6d7aa21"}
