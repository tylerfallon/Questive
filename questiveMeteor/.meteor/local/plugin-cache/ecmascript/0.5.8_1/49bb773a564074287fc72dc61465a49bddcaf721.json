{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"./accounts_client.js","imported":["AccountsClient"],"specifiers":[{"kind":"named","imported":"AccountsClient","local":"AccountsClient"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/accounts-base/localstorage_token.js","filenameRelative":"/packages/accounts-base/localstorage_token.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/accounts-base/localstorage_token.js.map","sourceFileName":"/packages/accounts-base/localstorage_token.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"localstorage_token"},"ignored":false,"code":"var AccountsClient;module.import(\"./accounts_client.js\",{\"AccountsClient\":function(v){AccountsClient=v}});\nvar Ap = AccountsClient.prototype;\n\n// This file deals with storing a login token and user id in the\n// browser's localStorage facility. It polls local storage every few\n// seconds to synchronize login state between multiple tabs in the same\n// browser.\n\n// Login with a Meteor access token. This is the only public function\n// here.\nMeteor.loginWithToken = function (token, callback) {\n  return Accounts.loginWithToken(token, callback);\n};\n\nAp.loginWithToken = function (token, callback) {\n  this.callLoginMethod({\n    methodArguments: [{\n      resume: token\n    }],\n    userCallback: callback\n  });\n};\n\n// Semi-internal API. Call this function to re-enable auto login after\n// if it was disabled at startup.\nAp._enableAutoLogin = function () {\n  this._autoLoginEnabled = true;\n  this._pollStoredLoginToken();\n};\n\n///\n/// STORING\n///\n\n// Call this from the top level of the test file for any test that does\n// logging in and out, to protect multiple tabs running the same tests\n// simultaneously from interfering with each others' localStorage.\nAp._isolateLoginTokenForTest = function () {\n  this.LOGIN_TOKEN_KEY = this.LOGIN_TOKEN_KEY + Random.id();\n  this.USER_ID_KEY = this.USER_ID_KEY + Random.id();\n};\n\nAp._storeLoginToken = function (userId, token, tokenExpires) {\n  Meteor._localStorage.setItem(this.USER_ID_KEY, userId);\n  Meteor._localStorage.setItem(this.LOGIN_TOKEN_KEY, token);\n  if (!tokenExpires) tokenExpires = this._tokenExpiration(new Date());\n  Meteor._localStorage.setItem(this.LOGIN_TOKEN_EXPIRES_KEY, tokenExpires);\n\n  // to ensure that the localstorage poller doesn't end up trying to\n  // connect a second time\n  this._lastLoginTokenWhenPolled = token;\n};\n\nAp._unstoreLoginToken = function () {\n  Meteor._localStorage.removeItem(this.USER_ID_KEY);\n  Meteor._localStorage.removeItem(this.LOGIN_TOKEN_KEY);\n  Meteor._localStorage.removeItem(this.LOGIN_TOKEN_EXPIRES_KEY);\n\n  // to ensure that the localstorage poller doesn't end up trying to\n  // connect a second time\n  this._lastLoginTokenWhenPolled = null;\n};\n\n// This is private, but it is exported for now because it is used by a\n// test in accounts-password.\n//\nAp._storedLoginToken = function () {\n  return Meteor._localStorage.getItem(this.LOGIN_TOKEN_KEY);\n};\n\nAp._storedLoginTokenExpires = function () {\n  return Meteor._localStorage.getItem(this.LOGIN_TOKEN_EXPIRES_KEY);\n};\n\nAp._storedUserId = function () {\n  return Meteor._localStorage.getItem(this.USER_ID_KEY);\n};\n\nAp._unstoreLoginTokenIfExpiresSoon = function () {\n  var tokenExpires = this._storedLoginTokenExpires();\n  if (tokenExpires && this._tokenExpiresSoon(new Date(tokenExpires))) {\n    this._unstoreLoginToken();\n  }\n};\n\n///\n/// AUTO-LOGIN\n///\n\nAp._initLocalStorage = function () {\n  var self = this;\n\n  // Key names to use in localStorage\n  self.LOGIN_TOKEN_KEY = \"Meteor.loginToken\";\n  self.LOGIN_TOKEN_EXPIRES_KEY = \"Meteor.loginTokenExpires\";\n  self.USER_ID_KEY = \"Meteor.userId\";\n\n  var rootUrlPathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX;\n  if (rootUrlPathPrefix || this.connection !== Meteor.connection) {\n    // We want to keep using the same keys for existing apps that do not\n    // set a custom ROOT_URL_PATH_PREFIX, so that most users will not have\n    // to log in again after an app updates to a version of Meteor that\n    // contains this code, but it's generally preferable to namespace the\n    // keys so that connections from distinct apps to distinct DDP URLs\n    // will be distinct in Meteor._localStorage.\n    var namespace = \":\" + this.connection._stream.rawUrl;\n    if (rootUrlPathPrefix) {\n      namespace += \":\" + rootUrlPathPrefix;\n    }\n    self.LOGIN_TOKEN_KEY += namespace;\n    self.LOGIN_TOKEN_EXPIRES_KEY += namespace;\n    self.USER_ID_KEY += namespace;\n  }\n\n  if (self._autoLoginEnabled) {\n    // Immediately try to log in via local storage, so that any DDP\n    // messages are sent after we have established our user account\n    self._unstoreLoginTokenIfExpiresSoon();\n    var token = self._storedLoginToken();\n    if (token) {\n      // On startup, optimistically present us as logged in while the\n      // request is in flight. This reduces page flicker on startup.\n      var userId = self._storedUserId();\n      userId && self.connection.setUserId(userId);\n      self.loginWithToken(token, function (err) {\n        if (err) {\n          Meteor._debug(\"Error logging in with token: \" + err);\n          self.makeClientLoggedOut();\n        }\n\n        self._pageLoadLogin({\n          type: \"resume\",\n          allowed: !err,\n          error: err,\n          methodName: \"login\",\n          // XXX This is duplicate code with loginWithToken, but\n          // loginWithToken can also be called at other times besides\n          // page load.\n          methodArguments: [{ resume: token }]\n        });\n      });\n    }\n  }\n\n  // Poll local storage every 3 seconds to login if someone logged in in\n  // another tab\n  self._lastLoginTokenWhenPolled = token;\n\n  if (self._pollIntervalTimer) {\n    // Unlikely that _initLocalStorage will be called more than once for\n    // the same AccountsClient instance, but just in case...\n    clearInterval(self._pollIntervalTimer);\n  }\n\n  self._pollIntervalTimer = setInterval(function () {\n    self._pollStoredLoginToken();\n  }, 3000);\n};\n\nAp._pollStoredLoginToken = function () {\n  var self = this;\n\n  if (!self._autoLoginEnabled) {\n    return;\n  }\n\n  var currentLoginToken = self._storedLoginToken();\n\n  // != instead of !== just to make sure undefined and null are treated the same\n  if (self._lastLoginTokenWhenPolled != currentLoginToken) {\n    if (currentLoginToken) {\n      self.loginWithToken(currentLoginToken, function (err) {\n        if (err) {\n          self.makeClientLoggedOut();\n        }\n      });\n    } else {\n      self.logout();\n    }\n  }\n\n  self._lastLoginTokenWhenPolled = currentLoginToken;\n};","ast":null,"map":{"version":3,"sources":["/packages/accounts-base/localstorage_token.js"],"names":[],"mappings":"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","file":"/packages/accounts-base/localstorage_token.js.map","sourcesContent":["import {AccountsClient} from \"./accounts_client.js\";\nvar Ap = AccountsClient.prototype;\n\n// This file deals with storing a login token and user id in the\n// browser's localStorage facility. It polls local storage every few\n// seconds to synchronize login state between multiple tabs in the same\n// browser.\n\n// Login with a Meteor access token. This is the only public function\n// here.\nMeteor.loginWithToken = function (token, callback) {\n  return Accounts.loginWithToken(token, callback);\n};\n\nAp.loginWithToken = function (token, callback) {\n  this.callLoginMethod({\n    methodArguments: [{\n      resume: token\n    }],\n    userCallback: callback\n  });\n};\n\n// Semi-internal API. Call this function to re-enable auto login after\n// if it was disabled at startup.\nAp._enableAutoLogin = function () {\n  this._autoLoginEnabled = true;\n  this._pollStoredLoginToken();\n};\n\n\n///\n/// STORING\n///\n\n// Call this from the top level of the test file for any test that does\n// logging in and out, to protect multiple tabs running the same tests\n// simultaneously from interfering with each others' localStorage.\nAp._isolateLoginTokenForTest = function () {\n  this.LOGIN_TOKEN_KEY = this.LOGIN_TOKEN_KEY + Random.id();\n  this.USER_ID_KEY = this.USER_ID_KEY + Random.id();\n};\n\nAp._storeLoginToken = function (userId, token, tokenExpires) {\n  Meteor._localStorage.setItem(this.USER_ID_KEY, userId);\n  Meteor._localStorage.setItem(this.LOGIN_TOKEN_KEY, token);\n  if (! tokenExpires)\n    tokenExpires = this._tokenExpiration(new Date());\n  Meteor._localStorage.setItem(this.LOGIN_TOKEN_EXPIRES_KEY, tokenExpires);\n\n  // to ensure that the localstorage poller doesn't end up trying to\n  // connect a second time\n  this._lastLoginTokenWhenPolled = token;\n};\n\nAp._unstoreLoginToken = function () {\n  Meteor._localStorage.removeItem(this.USER_ID_KEY);\n  Meteor._localStorage.removeItem(this.LOGIN_TOKEN_KEY);\n  Meteor._localStorage.removeItem(this.LOGIN_TOKEN_EXPIRES_KEY);\n\n  // to ensure that the localstorage poller doesn't end up trying to\n  // connect a second time\n  this._lastLoginTokenWhenPolled = null;\n};\n\n// This is private, but it is exported for now because it is used by a\n// test in accounts-password.\n//\nAp._storedLoginToken = function () {\n  return Meteor._localStorage.getItem(this.LOGIN_TOKEN_KEY);\n};\n\nAp._storedLoginTokenExpires = function () {\n  return Meteor._localStorage.getItem(this.LOGIN_TOKEN_EXPIRES_KEY);\n};\n\nAp._storedUserId = function () {\n  return Meteor._localStorage.getItem(this.USER_ID_KEY);\n};\n\nAp._unstoreLoginTokenIfExpiresSoon = function () {\n  var tokenExpires = this._storedLoginTokenExpires();\n  if (tokenExpires && this._tokenExpiresSoon(new Date(tokenExpires))) {\n    this._unstoreLoginToken();\n  }\n};\n\n///\n/// AUTO-LOGIN\n///\n\nAp._initLocalStorage = function () {\n  var self = this;\n\n  // Key names to use in localStorage\n  self.LOGIN_TOKEN_KEY = \"Meteor.loginToken\";\n  self.LOGIN_TOKEN_EXPIRES_KEY = \"Meteor.loginTokenExpires\";\n  self.USER_ID_KEY = \"Meteor.userId\";\n\n  var rootUrlPathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX;\n  if (rootUrlPathPrefix || this.connection !== Meteor.connection) {\n    // We want to keep using the same keys for existing apps that do not\n    // set a custom ROOT_URL_PATH_PREFIX, so that most users will not have\n    // to log in again after an app updates to a version of Meteor that\n    // contains this code, but it's generally preferable to namespace the\n    // keys so that connections from distinct apps to distinct DDP URLs\n    // will be distinct in Meteor._localStorage.\n    var namespace = \":\" + this.connection._stream.rawUrl;\n    if (rootUrlPathPrefix) {\n      namespace += \":\" + rootUrlPathPrefix;\n    }\n    self.LOGIN_TOKEN_KEY += namespace;\n    self.LOGIN_TOKEN_EXPIRES_KEY += namespace;\n    self.USER_ID_KEY += namespace;\n  }\n\n  if (self._autoLoginEnabled) {\n    // Immediately try to log in via local storage, so that any DDP\n    // messages are sent after we have established our user account\n    self._unstoreLoginTokenIfExpiresSoon();\n    var token = self._storedLoginToken();\n    if (token) {\n      // On startup, optimistically present us as logged in while the\n      // request is in flight. This reduces page flicker on startup.\n      var userId = self._storedUserId();\n      userId && self.connection.setUserId(userId);\n      self.loginWithToken(token, function (err) {\n        if (err) {\n          Meteor._debug(\"Error logging in with token: \" + err);\n          self.makeClientLoggedOut();\n        }\n\n        self._pageLoadLogin({\n          type: \"resume\",\n          allowed: !err,\n          error: err,\n          methodName: \"login\",\n          // XXX This is duplicate code with loginWithToken, but\n          // loginWithToken can also be called at other times besides\n          // page load.\n          methodArguments: [{resume: token}]\n        });\n      });\n    }\n  }\n\n  // Poll local storage every 3 seconds to login if someone logged in in\n  // another tab\n  self._lastLoginTokenWhenPolled = token;\n\n  if (self._pollIntervalTimer) {\n    // Unlikely that _initLocalStorage will be called more than once for\n    // the same AccountsClient instance, but just in case...\n    clearInterval(self._pollIntervalTimer);\n  }\n\n  self._pollIntervalTimer = setInterval(function () {\n    self._pollStoredLoginToken();\n  }, 3000);\n};\n\nAp._pollStoredLoginToken = function () {\n  var self = this;\n\n  if (! self._autoLoginEnabled) {\n    return;\n  }\n\n  var currentLoginToken = self._storedLoginToken();\n\n  // != instead of !== just to make sure undefined and null are treated the same\n  if (self._lastLoginTokenWhenPolled != currentLoginToken) {\n    if (currentLoginToken) {\n      self.loginWithToken(currentLoginToken, function (err) {\n        if (err) {\n          self.makeClientLoggedOut();\n        }\n      });\n    } else {\n      self.logout();\n    }\n  }\n\n  self._lastLoginTokenWhenPolled = currentLoginToken;\n};\n"]},"hash":"49bb773a564074287fc72dc61465a49bddcaf721"}
