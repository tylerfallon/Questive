{"metadata":{"usedHelpers":["classCallCheck"],"marked":[],"modules":{"imports":[{"source":"lodash","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_"}]},{"source":"../modules/core/utils/throw_parse_error.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"throwParseError"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/jagi:astronomy/lib/core/module.js","filenameRelative":"/packages/jagi:astronomy/lib/core/module.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/jagi:astronomy/lib/core/module.js.map","sourceFileName":"/packages/jagi:astronomy/lib/core/module.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"module"},"ignored":false,"code":"var _classCallCheck;module.import('babel-runtime/helpers/classCallCheck',{\"default\":function(v){_classCallCheck=v}});var _;module.import('lodash',{\"default\":function(v){_=v}});var throwParseError;module.import('../modules/core/utils/throw_parse_error.js',{\"default\":function(v){throwParseError=v}});\n\n\n\nvar Module = function () {\n\tfunction Module(definition) {\n\t\tvar _this = this;\n\n\t\t_classCallCheck(this, Module);\n\n\t\tif (!Match.test(definition, Object)) {\n\t\t\tthrowParseError(['Module definition has to be an object']);\n\t\t}\n\n\t\t// Set module name.\n\t\tif (!Match.test(definition.name, String)) {\n\t\t\tthrowParseError(['Module name has to be a string']);\n\t\t}\n\t\tvar moduleName = this.name = definition.name;\n\n\t\t// Set module hooks.\n\t\t_.each(['onInitSchema', 'onInitDefinition', 'onInitClass', 'onParseDefinition', 'onApplyDefinition', 'onMergeDefinitions'], function (hookName) {\n\t\t\tif (definition[hookName] === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!Match.test(definition[hookName], Function)) {\n\t\t\t\tthrowParseError([{\n\t\t\t\t\t'module': moduleName\n\t\t\t\t}, {\n\t\t\t\t\t'property': hookName\n\t\t\t\t}, 'The \"' + hookName + '\" hook has to be a function']);\n\t\t\t}\n\t\t\t_this[hookName] = definition[hookName];\n\t\t});\n\n\t\t// Set module utils.\n\t\tif (definition.utils) {\n\t\t\tif (!Match.test(definition.utils, Object)) {\n\t\t\t\tthrowParseError([{\n\t\t\t\t\t'module': moduleName\n\t\t\t\t}, {\n\t\t\t\t\t'property': 'utils'\n\t\t\t\t}, 'Utilities definition has to be an object']);\n\t\t\t}\n\t\t\tthis.utils = {};\n\t\t\t_.each(definition.utils, function (method, methodName) {\n\t\t\t\tif (!Match.test(method, Function)) {\n\t\t\t\t\tthrowParseError([{\n\t\t\t\t\t\t'module': moduleName\n\t\t\t\t\t}, {\n\t\t\t\t\t\t'property': 'utils'\n\t\t\t\t\t}, {\n\t\t\t\t\t\t'method': methodName\n\t\t\t\t\t}, 'Utility has to be a function']);\n\t\t\t\t}\n\t\t\t\t_this.utils[methodName] = method;\n\t\t\t});\n\t\t}\n\t}\n\n\tModule.prototype.onInitSchema = function onInitSchema(schema, className) {};\n\n\tModule.prototype.onInitDefinition = function onInitDefinition(definition, className) {};\n\n\tModule.prototype.onInitClass = function onInitClass(Class, className) {};\n\n\tModule.prototype.onParseDefinition = function onParseDefinition(parsedDefinition, definition, className) {};\n\n\tModule.prototype.onApplyDefinition = function onApplyDefinition(Class, definition, className) {};\n\n\tModule.prototype.onMergeDefinitions = function onMergeDefinitions(targetDefinition, sourceDefinition, className) {};\n\n\tModule.create = function create(definition) {\n\t\tvar module = new this(definition);\n\t\tthis.modules[module.name] = module;\n\t\tthis.modulesOrder.push(module.name);\n\t\treturn module;\n\t};\n\n\tModule.get = function get(moduleName) {\n\t\treturn this.modules[moduleName];\n\t};\n\n\tModule.forEach = function forEach(iteratee) {\n\t\tvar _this2 = this;\n\n\t\tif (!Match.test(iteratee, Function)) {\n\t\t\tthrowParseError(['The first argument of the \"Module.forEach\" method has to be a function']);\n\t\t}\n\t\t_.each(this.modulesOrder, function (moduleName) {\n\t\t\titeratee(_this2.modules[moduleName]);\n\t\t});\n\t};\n\n\treturn Module;\n}();\n\n;\n\nModule.modules = {};\nModule.modulesOrder = [];\n\nmodule.export(\"default\",exports.default=(Module));","ast":null,"map":{"version":3,"sources":["/packages/jagi:astronomy/lib/core/module.js"],"names":[],"mappings":";AAAA,OAAO,CAAP,MAAc,QAAd;AACA,OAAO,eAAP,MAA4B,4CAA5B;;IAEM,M;AACL,iBAAY,UAAZ,EAAwB;AAAA;;AAAA;;AACvB,MAAI,CAAC,MAAM,IAAN,CAAW,UAAX,EAAuB,MAAvB,CAAL,EAAqC;AACpC,mBAAgB,CACf,uCADe,CAAhB;AAGA;;;AAGD,MAAI,CAAC,MAAM,IAAN,CAAW,WAAW,IAAtB,EAA4B,MAA5B,CAAL,EAA0C;AACzC,mBAAgB,CACf,gCADe,CAAhB;AAGA;AACD,MAAI,aAAa,KAAK,IAAL,GAAY,WAAW,IAAxC;;;AAGA,IAAE,IAAF,CAAO,CACN,cADM,EACU,kBADV,EAC8B,aAD9B,EAC6C,mBAD7C,EAEN,mBAFM,EAEe,oBAFf,CAAP,EAGG,UAAC,QAAD,EAAc;AAChB,OAAI,WAAW,QAAX,MAAyB,SAA7B,EAAwC;AACvC;AACA;AACD,OAAI,CAAC,MAAM,IAAN,CAAW,WAAW,QAAX,CAAX,EAAiC,QAAjC,CAAL,EAAiD;AAChD,oBAAgB,CAAC;AACf,eAAU;AADK,KAAD,EAEZ;AACF,iBAAY;AADV,KAFY,YAKP,QALO,iCAAhB;AAOA;AACD,SAAK,QAAL,IAAiB,WAAW,QAAX,CAAjB;AACA,GAjBD;;;AAoBA,MAAI,WAAW,KAAf,EAAsB;AACrB,OAAI,CAAC,MAAM,IAAN,CAAW,WAAW,KAAtB,EAA6B,MAA7B,CAAL,EAA2C;AAC1C,oBAAgB,CAAC;AACf,eAAU;AADK,KAAD,EAEZ;AACF,iBAAY;AADV,KAFY,EAKf,0CALe,CAAhB;AAOA;AACD,QAAK,KAAL,GAAa,EAAb;AACA,KAAE,IAAF,CAAO,WAAW,KAAlB,EAAyB,UAAC,MAAD,EAAS,UAAT,EAAwB;AAChD,QAAI,CAAC,MAAM,IAAN,CAAW,MAAX,EAAmB,QAAnB,CAAL,EAAmC;AAClC,qBAAgB,CAAC;AACf,gBAAU;AADK,MAAD,EAEZ;AACF,kBAAY;AADV,MAFY,EAIZ;AACF,gBAAU;AADR,MAJY,EAOf,8BAPe,CAAhB;AASA;AACD,UAAK,KAAL,CAAW,UAAX,IAAyB,MAAzB;AACA,IAbD;AAcA;AACD;;kBAED,Y,yBAAa,M,EAAQ,S,EAAW,CAAE,C;;kBAClC,gB,6BAAiB,U,EAAY,S,EAAW,CAAE,C;;kBAE1C,W,wBAAY,K,EAAO,S,EAAW,CAAE,C;;kBAEhC,iB,8BAAkB,gB,EAAkB,U,EAAY,S,EAAW,CAAE,C;;kBAC7D,iB,8BAAkB,K,EAAO,U,EAAY,S,EAAW,CAAE,C;;kBAClD,kB,+BAAmB,gB,EAAkB,gB,EAAkB,S,EAAW,CAAE,C;;QAE7D,M,mBAAO,U,EAAY;AACzB,MAAI,SAAS,IAAI,IAAJ,CAAS,UAAT,CAAb;AACA,OAAK,OAAL,CAAa,OAAO,IAApB,IAA4B,MAA5B;AACA,OAAK,YAAL,CAAkB,IAAlB,CAAuB,OAAO,IAA9B;AACA,SAAO,MAAP;AACA,E;;QAEM,G,gBAAI,U,EAAY;AACtB,SAAO,KAAK,OAAL,CAAa,UAAb,CAAP;AACA,E;;QAEM,O,oBAAQ,Q,EAAU;AAAA;;AACxB,MAAI,CAAC,MAAM,IAAN,CAAW,QAAX,EAAqB,QAArB,CAAL,EAAqC;AACpC,mBAAgB,CACf,wEADe,CAAhB;AAGA;AACD,IAAE,IAAF,CAAO,KAAK,YAAZ,EAA0B,UAAC,UAAD,EAAgB;AACzC,YAAS,OAAK,OAAL,CAAa,UAAb,CAAT;AACA,GAFD;AAGA,E;;;;;AACD;;AAED,OAAO,OAAP,GAAiB,EAAjB;AACA,OAAO,YAAP,GAAsB,EAAtB;;AAEA,eAAe,MAAf","file":"/packages/jagi:astronomy/lib/core/module.js.map","sourcesContent":["import _ from 'lodash';\nimport throwParseError from '../modules/core/utils/throw_parse_error.js';\n\nclass Module {\n\tconstructor(definition) {\n\t\tif (!Match.test(definition, Object)) {\n\t\t\tthrowParseError([\n\t\t\t\t'Module definition has to be an object'\n\t\t\t]);\n\t\t}\n\n\t\t// Set module name.\n\t\tif (!Match.test(definition.name, String)) {\n\t\t\tthrowParseError([\n\t\t\t\t'Module name has to be a string'\n\t\t\t]);\n\t\t}\n\t\tlet moduleName = this.name = definition.name;\n\n\t\t// Set module hooks.\n\t\t_.each([\n\t\t\t'onInitSchema', 'onInitDefinition', 'onInitClass', 'onParseDefinition',\n\t\t\t'onApplyDefinition', 'onMergeDefinitions'\n\t\t], (hookName) => {\n\t\t\tif (definition[hookName] === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!Match.test(definition[hookName], Function)) {\n\t\t\t\tthrowParseError([{\n\t\t\t\t\t\t'module': moduleName\n\t\t\t\t\t}, {\n\t\t\t\t\t\t'property': hookName\n\t\t\t\t\t},\n\t\t\t\t\t`The \"${hookName}\" hook has to be a function`\n\t\t\t\t]);\n\t\t\t}\n\t\t\tthis[hookName] = definition[hookName];\n\t\t});\n\n\t\t// Set module utils.\n\t\tif (definition.utils) {\n\t\t\tif (!Match.test(definition.utils, Object)) {\n\t\t\t\tthrowParseError([{\n\t\t\t\t\t\t'module': moduleName\n\t\t\t\t\t}, {\n\t\t\t\t\t\t'property': 'utils'\n\t\t\t\t\t},\n\t\t\t\t\t'Utilities definition has to be an object'\n\t\t\t\t]);\n\t\t\t}\n\t\t\tthis.utils = {};\n\t\t\t_.each(definition.utils, (method, methodName) => {\n\t\t\t\tif (!Match.test(method, Function)) {\n\t\t\t\t\tthrowParseError([{\n\t\t\t\t\t\t\t'module': moduleName\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t'property': 'utils'\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t'method': methodName\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'Utility has to be a function'\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t\tthis.utils[methodName] = method;\n\t\t\t});\n\t\t}\n\t}\n\n\tonInitSchema(schema, className) {}\n\tonInitDefinition(definition, className) {}\n\n\tonInitClass(Class, className) {}\n\n\tonParseDefinition(parsedDefinition, definition, className) {}\n\tonApplyDefinition(Class, definition, className) {}\n\tonMergeDefinitions(targetDefinition, sourceDefinition, className) {}\n\n\tstatic create(definition) {\n\t\tlet module = new this(definition);\n\t\tthis.modules[module.name] = module;\n\t\tthis.modulesOrder.push(module.name);\n\t\treturn module;\n\t}\n\n\tstatic get(moduleName) {\n\t\treturn this.modules[moduleName];\n\t}\n\n\tstatic forEach(iteratee) {\n\t\tif (!Match.test(iteratee, Function)) {\n\t\t\tthrowParseError([\n\t\t\t\t'The first argument of the \"Module.forEach\" method has to be a function'\n\t\t\t]);\n\t\t}\n\t\t_.each(this.modulesOrder, (moduleName) => {\n\t\t\titeratee(this.modules[moduleName]);\n\t\t});\n\t}\n};\n\nModule.modules = {};\nModule.modulesOrder = [];\n\nexport default Module;"]},"hash":"2352225fc4ae742991b17dd3e6d837631597ab5d"}
