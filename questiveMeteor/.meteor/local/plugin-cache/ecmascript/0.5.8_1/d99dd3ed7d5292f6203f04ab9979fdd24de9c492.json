{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"lodash","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_"}]},{"source":"../../fields/utils/resolve_values.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"resolveValues"}]},{"source":"../utils/has_meteor_method.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"hasMeteorMethod"}]},{"source":"../class_static_methods/find.js","imported":["find","findOne"],"specifiers":[{"kind":"named","imported":"find","local":"find"},{"kind":"named","imported":"findOne","local":"findOne"}]},{"source":"../class_static_methods/insert.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"insert"}]},{"source":"../class_static_methods/update.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"update"}]},{"source":"../class_static_methods/upsert.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"upsert"}]},{"source":"../class_static_methods/remove.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"remove"}]},{"source":"../class_prototype_methods/save.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"protoSave"}]},{"source":"../class_prototype_methods/remove.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"protoRemove"}]},{"source":"../class_prototype_methods/reload.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"protoReload"}]},{"source":"../class_prototype_methods/copy.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"protoCopy"}]},{"source":"../class_prototype_methods/get_modifier.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"protoGetModifier"}]},{"source":"../class_prototype_methods/get_modified.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"protoGetModified"}]},{"source":"../class_prototype_methods/get_modified_values.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"protoGetModifiedValues"}]},{"source":"../class_prototype_methods/is_modified.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"protoIsModified"}]},{"source":"../meteor_methods/insert.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"meteorInsert"}]},{"source":"../meteor_methods/update.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"meteorUpdate"}]},{"source":"../meteor_methods/upsert.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"meteorUpsert"}]},{"source":"../meteor_methods/remove.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"meteorRemove"}]},{"source":"../class_events/before_init.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"beforeInit"}]},{"source":"../class_events/after_init.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"afterInit"}]},{"source":"../class_events/from_json_value.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"fromJSONValue"}]},{"source":"../class_events/to_json_value.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"toJSONValue"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/jagi:astronomy/lib/modules/storage/hooks/apply_definition.js","filenameRelative":"/packages/jagi:astronomy/lib/modules/storage/hooks/apply_definition.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/jagi:astronomy/lib/modules/storage/hooks/apply_definition.js.map","sourceFileName":"/packages/jagi:astronomy/lib/modules/storage/hooks/apply_definition.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"apply_definition"},"ignored":false,"code":"var _;module.import('lodash',{\"default\":function(v){_=v}});var resolveValues;module.import('../../fields/utils/resolve_values.js',{\"default\":function(v){resolveValues=v}});var hasMeteorMethod;module.import('../utils/has_meteor_method.js',{\"default\":function(v){hasMeteorMethod=v}});var find,findOne;module.import('../class_static_methods/find.js',{\"find\":function(v){find=v},\"findOne\":function(v){findOne=v}});var insert;module.import('../class_static_methods/insert.js',{\"default\":function(v){insert=v}});var update;module.import('../class_static_methods/update.js',{\"default\":function(v){update=v}});var upsert;module.import('../class_static_methods/upsert.js',{\"default\":function(v){upsert=v}});var remove;module.import('../class_static_methods/remove.js',{\"default\":function(v){remove=v}});var protoSave;module.import('../class_prototype_methods/save.js',{\"default\":function(v){protoSave=v}});var protoRemove;module.import('../class_prototype_methods/remove.js',{\"default\":function(v){protoRemove=v}});var protoReload;module.import('../class_prototype_methods/reload.js',{\"default\":function(v){protoReload=v}});var protoCopy;module.import('../class_prototype_methods/copy.js',{\"default\":function(v){protoCopy=v}});var protoGetModifier;module.import('../class_prototype_methods/get_modifier.js',{\"default\":function(v){protoGetModifier=v}});var protoGetModified;module.import('../class_prototype_methods/get_modified.js',{\"default\":function(v){protoGetModified=v}});var protoGetModifiedValues;module.import('../class_prototype_methods/get_modified_values.js',{\"default\":function(v){protoGetModifiedValues=v}});var protoIsModified;module.import('../class_prototype_methods/is_modified.js',{\"default\":function(v){protoIsModified=v}});var meteorInsert;module.import('../meteor_methods/insert.js',{\"default\":function(v){meteorInsert=v}});var meteorUpdate;module.import('../meteor_methods/update.js',{\"default\":function(v){meteorUpdate=v}});var meteorUpsert;module.import('../meteor_methods/upsert.js',{\"default\":function(v){meteorUpsert=v}});var meteorRemove;module.import('../meteor_methods/remove.js',{\"default\":function(v){meteorRemove=v}});var beforeInit;module.import('../class_events/before_init.js',{\"default\":function(v){beforeInit=v}});var afterInit;module.import('../class_events/after_init.js',{\"default\":function(v){afterInit=v}});var fromJSONValue;module.import('../class_events/from_json_value.js',{\"default\":function(v){fromJSONValue=v}});var toJSONValue;module.import('../class_events/to_json_value.js',{\"default\":function(v){toJSONValue=v}});\n// Utils.\n\n\n// Class static methods.\n\n\n\n\n\n// Class prototype methods.\n\n\n\n\n\n\n\n\n// Meteor methods.\n\n\n\n\n// Class events.\n\n\n\n\n\nfunction onApplyDefinition(Class, parsedDefinition, className) {\n  var schema = Class.schema;\n\n  if (parsedDefinition.collection) {\n    (function () {\n      var Collection = schema.collection = parsedDefinition.collection;\n      var id = Collection._makeNewID();\n\n      Class.extend({\n        // Add the \"_id\" field.\n        fields: {\n          _id: {\n            name: '_id',\n            type: id.constructor,\n            optional: true\n          }\n        },\n        // Add storage events.\n        events: {\n          beforeInit: [beforeInit],\n          toJSONValue: [toJSONValue],\n          fromJSONValue: [fromJSONValue]\n        }\n      }, ['fields', 'events']);\n\n      // If it's a remote collection then we register methods on the connection\n      // object of the collection.\n      var connection = Collection._connection;\n      if (connection) {\n        // Prepare meteor methods to be added.\n        var meteorMethods = {\n          '/Astronomy/insert': meteorInsert,\n          '/Astronomy/update': meteorUpdate,\n          '/Astronomy/upsert': meteorUpsert,\n          '/Astronomy/remove': meteorRemove\n        };\n        _.each(meteorMethods, function (meteorMethod, methodName) {\n          if (!hasMeteorMethod(connection, methodName)) {\n            // Add meteor method.\n            connection.methods(_.zipObject([methodName], [meteorMethod]));\n          }\n        });\n      }\n\n      // Class static methods.\n      Class.find = find;\n      Class.findOne = findOne;\n      Class.insert = insert;\n      Class.update = update;\n      Class.upsert = upsert;\n      Class.remove = remove;\n      // Class prototype methods.\n      Class.prototype.save = protoSave;\n      Class.prototype.remove = protoRemove;\n      Class.prototype.reload = protoReload;\n      Class.prototype.copy = protoCopy;\n      Class.prototype.getModifier = protoGetModifier;\n      Class.prototype.getModified = protoGetModified;\n      Class.prototype.getModifiedValues = protoGetModifiedValues;\n      Class.prototype.isModified = protoIsModified;\n    })();\n  }\n\n  // Apply type field.\n  if (parsedDefinition.typeField) {\n    var _fields;\n\n    var typeField = schema.typeField = parsedDefinition.typeField;\n    Class.extend({\n      // Add the type field.\n      fields: (_fields = {}, _fields[typeField] = {\n        type: String\n      }, _fields),\n      events: {\n        afterInit: [afterInit]\n      }\n    }, ['fields', 'events']);\n\n    if (parsedDefinition.typeField) {\n      schema.typeField = parsedDefinition.typeField;\n    }\n  }\n\n  // If class has already assigned collection.\n  var Collection = Class.getCollection();\n  if (Collection) {\n    // Apply custom transformation function if the transform property is a\n    // function.\n    if (_.isFunction(parsedDefinition.transform)) {\n      schema.transform = function (rawDoc) {\n        var resolvedDoc = resolveValues({\n          Class: Class,\n          values: rawDoc\n        });\n        return parsedDefinition.transform(resolvedDoc);\n      };\n    } else if (parsedDefinition.transform === null) {\n      schema.transform = null;\n    }\n\n    if (parsedDefinition.secured !== undefined) {\n      _.extend(schema.secured, parsedDefinition.secured);\n    }\n  }\n};\n\nmodule.export(\"default\",exports.default=(onApplyDefinition));","ast":null,"map":{"version":3,"sources":["/packages/jagi:astronomy/lib/modules/storage/hooks/apply_definition.js"],"names":[],"mappings":"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","file":"/packages/jagi:astronomy/lib/modules/storage/hooks/apply_definition.js.map","sourcesContent":["import _ from 'lodash';\n// Utils.\nimport resolveValues from '../../fields/utils/resolve_values.js';\nimport hasMeteorMethod from '../utils/has_meteor_method.js';\n// Class static methods.\nimport { find, findOne } from '../class_static_methods/find.js';\nimport insert from '../class_static_methods/insert.js';\nimport update from '../class_static_methods/update.js';\nimport upsert from '../class_static_methods/upsert.js';\nimport remove from '../class_static_methods/remove.js';\n// Class prototype methods.\nimport protoSave from '../class_prototype_methods/save.js';\nimport protoRemove from '../class_prototype_methods/remove.js';\nimport protoReload from '../class_prototype_methods/reload.js';\nimport protoCopy from '../class_prototype_methods/copy.js';\nimport protoGetModifier from '../class_prototype_methods/get_modifier.js';\nimport protoGetModified from '../class_prototype_methods/get_modified.js';\nimport protoGetModifiedValues from '../class_prototype_methods/get_modified_values.js';\nimport protoIsModified from '../class_prototype_methods/is_modified.js';\n// Meteor methods.\nimport meteorInsert from '../meteor_methods/insert.js';\nimport meteorUpdate from '../meteor_methods/update.js';\nimport meteorUpsert from '../meteor_methods/upsert.js';\nimport meteorRemove from '../meteor_methods/remove.js';\n// Class events.\nimport beforeInit from '../class_events/before_init.js';\nimport afterInit from '../class_events/after_init.js';\nimport fromJSONValue from '../class_events/from_json_value.js';\nimport toJSONValue from '../class_events/to_json_value.js';\n\nfunction onApplyDefinition(Class, parsedDefinition, className) {\n  const schema = Class.schema;\n\n  if (parsedDefinition.collection) {\n    const Collection = schema.collection = parsedDefinition.collection;\n    const id = Collection._makeNewID();\n\n    Class.extend({\n      // Add the \"_id\" field.\n      fields: {\n        _id: {\n          name: '_id',\n          type: id.constructor,\n          optional: true\n        }\n      },\n      // Add storage events.\n      events: {\n        beforeInit: [beforeInit],\n        toJSONValue: [toJSONValue],\n        fromJSONValue: [fromJSONValue]\n      }\n    }, ['fields', 'events']);\n\n    // If it's a remote collection then we register methods on the connection\n    // object of the collection.\n    const connection = Collection._connection;\n    if (connection) {\n      // Prepare meteor methods to be added.\n      const meteorMethods = {\n        '/Astronomy/insert': meteorInsert,\n        '/Astronomy/update': meteorUpdate,\n        '/Astronomy/upsert': meteorUpsert,\n        '/Astronomy/remove': meteorRemove,\n      };\n      _.each(meteorMethods, (meteorMethod, methodName) => {\n        if (!hasMeteorMethod(connection, methodName)) {\n          // Add meteor method.\n          connection.methods(_.zipObject([methodName], [meteorMethod]));\n        }\n      });\n    }\n\n    // Class static methods.\n    Class.find = find;\n    Class.findOne = findOne;\n    Class.insert = insert;\n    Class.update = update;\n    Class.upsert = upsert;\n    Class.remove = remove;\n    // Class prototype methods.\n    Class.prototype.save = protoSave;\n    Class.prototype.remove = protoRemove;\n    Class.prototype.reload = protoReload;\n    Class.prototype.copy = protoCopy;\n    Class.prototype.getModifier = protoGetModifier;\n    Class.prototype.getModified = protoGetModified;\n    Class.prototype.getModifiedValues = protoGetModifiedValues;\n    Class.prototype.isModified = protoIsModified;\n  }\n\n  // Apply type field.\n  if (parsedDefinition.typeField) {\n    const typeField = schema.typeField = parsedDefinition.typeField;\n    Class.extend({\n      // Add the type field.\n      fields: {\n        [typeField]: {\n          type: String\n        }\n      },\n      events: {\n        afterInit: [afterInit]\n      }\n    }, ['fields', 'events']);\n\n    if (parsedDefinition.typeField) {\n      schema.typeField = parsedDefinition.typeField;\n    }\n  }\n\n  // If class has already assigned collection.\n  const Collection = Class.getCollection();\n  if (Collection) {\n    // Apply custom transformation function if the transform property is a\n    // function.\n    if (_.isFunction(parsedDefinition.transform)) {\n      schema.transform = function(rawDoc) {\n        const resolvedDoc = resolveValues({\n          Class,\n          values: rawDoc\n        });\n        return parsedDefinition.transform(resolvedDoc);\n      };\n    }\n    else if (parsedDefinition.transform === null) {\n      schema.transform = null;\n    }\n\n    if (parsedDefinition.secured !== undefined) {\n      _.extend(schema.secured, parsedDefinition.secured);\n    }\n  }\n};\n\nexport default onApplyDefinition;"]},"hash":"d99dd3ed7d5292f6203f04ab9979fdd24de9c492"}
